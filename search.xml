<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一篇文章让你学会KMP算法</title>
      <link href="/2022/11/24/kmp2/"/>
      <url>/2022/11/24/kmp2/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-KMP算法是什么？"><a href="#1-KMP算法是什么？" class="headerlink" title="1. KMP算法是什么？"></a>1. KMP算法是什么？</h1><p>提出一个问题，给你两个字符串s和p（p的长度不超过s的长度，且s和p都不是空的），问s中是否包含p？</p><p>例如：</p><ol><li>s&#x3D;“hello, java”, p &#x3D; “java”，那么s包含p</li><li>s&#x3D;“github”, p&#x3D;“ppt”, s不包含p</li></ol><p>能否写出一个程序高效地解决这个问题。</p><p>我们能容易想到这样的方法：</p><p>设置两个指针，i和j，都初始化为0，我们对比s在i位置，p在j位置的字符。如果s[i]&#x3D;&#x3D;p[j]，那么i和j都移到下一个位置。否则j回退到0，i回退到1，继续上述过程，如果在下一次比较中，还是出现了不匹配的字符，那么j回退到0，i回退到2，继续……，周而复始。直到某一次匹配中，如果j到达越界位置，那么s包含p，否则s不包含p。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrContains</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ls</span> <span class="operator">=</span> s.length(), lp = p.length(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= ls - lp) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; lp &amp;&amp; s.charAt(x) == p.charAt(j)) &#123;</span><br><span class="line">                ++x;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == lp) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的查找方法，在遇到s&#x3D;“aaaaaaaaaaaaab”，p&#x3D;“aab”这样的情况的时候，会使得p只有在最后一次匹配的时候，才可以得到匹配。假设s的长度是$N$，p的长度是$M$，那么显然的最坏情况下时间复杂度就是$O(N*M)$。而KMP算法能做到最坏情况下$O(N+M)$的时间复杂度。它是怎么做的呢？我们一起来看看吧。</p><h1 id="2-KMP算法的计算过程"><a href="#2-KMP算法的计算过程" class="headerlink" title="2. KMP算法的计算过程"></a>2. KMP算法的计算过程</h1><h2 id="2-1-一个启发过程"><a href="#2-1-一个启发过程" class="headerlink" title="2.1. 一个启发过程"></a>2.1. 一个启发过程</h2><p>我们上面的暴力方法是基于这样的一个尝试的思路，如果s中有一个子串和p是匹配的，因为任何一个子串都有一个开头位置，那么这个和p匹配的子串当然也有一个开头位置，又因为我们不知道哪个开头位置的子串和p是匹配的，因此我们尝试所有可能的开头。如果我们尝试完所有的开头位置，都没有发现一个子串可以和p匹配，那么s中就没有一个子串和匹配，即s不包含p，反之s包含p。那么这个过程它为什么低效呢？我们来看一下s&#x3D;“aaaaaaaaab”和p&#x3D;“aaab”的匹配过程。</p><img src="kmp1.svg"><p>当我们发现某一个开头的尝试已经宣告失败的时候，此时只能选择下一个开头，继续从头开始匹配。那么此时指向s的指针会回退，之前已经匹配的部分结果完全抛弃，从新开始，因此这个方法是低效的。</p><p>如果某一次尝试失败了，那么之前已经匹配的部分（之前做过的努力）能否给我们提供一些帮助，加速我们的匹配过程，甚至能使得字符串s上的指针不回退呢？我们调整的时候，需要遵循什么原则呢？</p><img src="kmp2.svg"><p>为了便于说明j的调整，下面我们举一个明显的例子。请看字符串s&#x3D;“acacab”，和字符串p&#x3D;“acab”的匹配过程。</p><img src="kmp3.svg"><p>那么如果已经匹配的部分有多个前缀和后缀是匹配的呢？我们怎么选择？请看s&#x3D;“aaaab”和p&#x3D;“aaab”的匹配过程。</p><img src="kmp4.svg"><p>总结一下：此时我们似乎找到了，保证s指针不回退的时候，p的指针的调整方案，即当我们发现某一次匹配失败的时候，我们需要找出<strong>前面已经匹配部分的<font color="red">前后缀最大匹配长度</font>，假设为next，那么我们只需要把j调整为next</strong>，继续进行匹配操作即可。</p><h2 id="2-2-next数组"><a href="#2-2-next数组" class="headerlink" title="2.2. next数组"></a>2.2. next数组</h2><h3 id="2-2-1-什么是next数组？"><a href="#2-2-1-什么是next数组？" class="headerlink" title="2.2.1. 什么是next数组？"></a>2.2.1. 什么是next数组？</h3><p>ß我们在进行真正的匹配之前，我们要先计算好，每一个元素的next值（next值的含义就是当前元素失去匹配的时候，它前面部分字符串的前后缀最大匹配长度，这个前后缀不包含自己），看下面对字符串“caccacb”的next值的定义过程：</p><img src="kmp5.svg"><h3 id="2-2-2-使用next数组加速匹配过程"><a href="#2-2-2-使用next数组加速匹配过程" class="headerlink" title="2.2.2. 使用next数组加速匹配过程"></a>2.2.2. 使用next数组加速匹配过程</h3><p>如果我们在匹配之前，得到这么一个，关于模式串p的每一个位置index失去匹配后，模式串的匹配指针应该调整为next[index]的next数组的话，那么我们的匹配过程可以变成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrContainsKmp</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ls</span> <span class="operator">=</span> s.length(), lp = p.length(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = getNext(p);<span class="comment">//获取关于模式串p的next数组</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= ls - lp &amp;&amp; j &lt; lp) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == p.charAt(j)) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果模式串p的第一个字符p[0]和字符串s的当前字符s[i]都不匹配，</span></span><br><span class="line"><span class="comment">            那么说明s中从i开始不可能匹配出p来，因此换下一个开头继续尝试</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) ++i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            否则j位置不是0，说明它前面有匹配成功的部分，</span></span><br><span class="line"><span class="comment">            那么此时j应该调整为next[j]的位置</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == lp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>next数组能加速匹配过程，可以从下面两个方面来理解：</p><ol><li><p>保证i指针不回退，指导j指针的调整</p><p>在我们匹配失败的时候，它可以利用我们之前已经匹配的部分字符串（以前做过的努力），在保证i（字符串s的匹配指针）不回退的情况下，指导此时指针j（模式串的匹配指针）应该做怎样的调整。前面的图示已经向大家说明了这一点。</p></li><li><p>跳过了一些无需验证的可能性</p><p>还记得我们的暴力做法吗？它尝试字符串s中每一个可能的开头位置（即验证所有的可能性），而next数组指导j的调整，可以跳过一些根本不可能匹配出来模式串p的位置，如下图所示：</p></li></ol><img src="kmp6.svg"><p>这两种理解是等价的。</p><h3 id="2-2-3-next数组正确性分析"><a href="#2-2-3-next数组正确性分析" class="headerlink" title="2.2.3. next数组正确性分析"></a>2.2.3. next数组正确性分析</h3><p>上面我们举了一个例子说明next数组能够指导j指针的调整，同时保证i指针不回退，并且还能跳过那些不可能的开头位置。那么为什么呢？我们这里给出一般性的说明。如图所示：</p><img src="kmp7.svg"><h3 id="2-2-4-求解next数组"><a href="#2-2-4-求解next数组" class="headerlink" title="2.2.4. 求解next数组"></a>2.2.4. 求解next数组</h3><p>既然next数组这么好用，我们如何快速得到它呢？</p><img src="kmp8.svg"><h1 id="3-代码和测试程序"><a href="#3-代码和测试程序" class="headerlink" title="3. 代码和测试程序"></a>3. 代码和测试程序</h1><h2 id="3-1-完整代码"><a href="#3-1-完整代码" class="headerlink" title="3.1. 完整代码"></a>3.1. 完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrContainsKmp</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ls</span> <span class="operator">=</span> s.length(), lp = p.length(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[lp];</span><br><span class="line">        getNextArray(p, next);<span class="comment">//获取关于模式串p的next数组</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; ls &amp;&amp; j &lt; lp) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == p.charAt(j)) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++j;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果模式串p的第一个字符p[0]和字符串s的当前字符s[i]都不匹配，</span></span><br><span class="line"><span class="comment">            那么说明s中从i开始不可能匹配出p来，因此换下一个开头继续尝试</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) ++i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            否则j位置不是0，说明它前面有匹配成功的部分，</span></span><br><span class="line"><span class="comment">            那么此时j应该调整为next[j]的位置</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == lp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getNextArray</span><span class="params">(String p, <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> p.length();</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//i: 当前要求解next[i]</span></span><br><span class="line">        <span class="comment">//cn: cn始终记录next[i - 1]的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, cn = next[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(i - <span class="number">1</span>) == p.charAt(cn)) next[i++] = ++cn;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cn == <span class="number">0</span>) next[i++] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> cn = next[cn];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-复杂度分析"><a href="#3-2-复杂度分析" class="headerlink" title="3.2. 复杂度分析"></a>3.2. 复杂度分析</h2><p>设字符串s的长度是$N$，p的长度是$M$，我们看估计contains方法中while循环体的一共执行多少次。我们设置两个量，一个是$i$，一个是$i-j$，其中i的范围$[0,N]$，i-j的范围$[0,N]$。</p><ol><li>如果代码命中第7行的分支，那么会推高$i$，但是$i-j$保持不变</li><li>如果代码命中第15行的分支，那么$i$和$i-j$都会被推高</li><li>如果代码命中第21行的分支，那么$i$保持不变，$i-j$会被推高。</li></ol><p>且在整个while的执行过程中变量$i$和$i-j$不会减小，那么这个while循环运行的结果就是把这两个变量不断推到最大值。可以知道这两个变量的最大值都是$N$，因此while循环的执行次数不会超过$2N$次，因此时间复杂度$O(N)$。</p><p>空间复杂度$O(N)$。</p><h2 id="3-3-测试程序"><a href="#3-3-测试程序" class="headerlink" title="3.3. 测试程序"></a>3.3. 测试程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrContainsTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxStrLen = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span>(times-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> r.nextInt(maxStrLen) + <span class="number">2</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getRandomStr(r, len);</span><br><span class="line">            String p;</span><br><span class="line">            <span class="keyword">if</span>(r.nextInt(<span class="number">2</span>) == <span class="number">0</span>) </span><br><span class="line">                p = s.substring(r.nextInt(len));</span><br><span class="line">            <span class="keyword">else</span> p = getRandomStr(r, r.nextInt(len) + <span class="number">1</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ans1</span> <span class="operator">=</span> StrContains.contains(s, p);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ans2</span> <span class="operator">=</span> StrContainsKmp.contains(s, p);</span><br><span class="line">            <span class="keyword">if</span>(ans1 ^ ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Oops!, wrong answer, ans1 = &quot;</span> + ans1 + <span class="string">&quot;, ans2 = &quot;</span> + ans2);</span><br><span class="line">                System.out.println(<span class="string">&quot;s: &quot;</span> + s);</span><br><span class="line">                System.out.println(<span class="string">&quot;p: &quot;</span> + p);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + times + <span class="string">&quot; done!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test done successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getRandomStr</span><span class="params">(Random r, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(len-- &gt; <span class="number">0</span>) </span><br><span class="line">            bd.append((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + r.nextInt(<span class="number">26</span>)));</span><br><span class="line">        <span class="keyword">return</span> bd.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 查找 </category>
          
          <category> KMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串模式匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出现K次的数字</title>
      <link href="/2022/11/23/appear-K-times-number/"/>
      <url>/2022/11/23/appear-K-times-number/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>给定一个数组arr，其中只有一个数字出现了K次，剩余的数字都出现M次，且$1\le K&lt;M$，找出这个出现K次的数。</p><h1 id="2-暴力做法"><a href="#2-暴力做法" class="headerlink" title="2. 暴力做法"></a>2. 暴力做法</h1><p>使用哈希表统计每一个数出现的次数，最后遍历哈希表，返回出现K次的数。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppearKTimesNumber</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKTimesNum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length, i = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">cnt</span> <span class="operator">=</span> countMap.get(arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="literal">null</span>) cnt = <span class="number">0</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">            countMap.put(arr[i], cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer number : countMap.keySet()) </span><br><span class="line">            <span class="keyword">if</span>(countMap.get(number) == k) <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N)$，空间复杂度$O(N)$。</p><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><p>int类型的底层是32位2进制数，我们统计所有数的二进制位上1的个数，我们假设答案ans上某一位是1，那么这个1要么出现$K$次，要么出现$K+xM(x \ge 0)$次，如果ans上的某一位是0，那么这一位上1的个数，只可能是$M$的倍数。因此我们可以根据某一位上1出现的次数，能否被$M$整除，就可以知道答案ans这一位是0还是1，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppearKTimesNumber2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKTimesNum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length, i = <span class="number">0</span>, j, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] bitCnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; len; ++i) </span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span>((arr[i] &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) ++bitCnt[j];</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span>(bitCnt[j] % m != <span class="number">0</span>) ans |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N)$，空间复杂度$O(1)$。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppearKTimesNumberTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxM = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(times-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> r.nextInt(maxM) + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt(m - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mTime</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> m * mTime + k;</span><br><span class="line">            <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[size], arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mTime; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">                <span class="keyword">while</span>(set.contains(num)) num = r.nextInt();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; m; ++x) &#123;</span><br><span class="line">                    arr1[j] = arr2[j] = arr3[j] = num;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">            <span class="keyword">while</span>(set.contains(num)) num = r.nextInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; k; ++x) &#123;</span><br><span class="line">                arr1[j] = arr2[j] = arr3[j] = num;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> AppearKTimesNumber.findKTimesNum(arr1, k, m);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> AppearKTimesNumber2.findKTimesNum(arr2, k, m);</span><br><span class="line">            <span class="keyword">if</span>(ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Oops!, wrong answer, ans1 = &quot;</span> + ans1 + <span class="string">&quot;, ans2 = &quot;</span> + ans2 + <span class="string">&quot;, k = &quot;</span> + k + <span class="string">&quot;, m = &quot;</span> + m);</span><br><span class="line">                System.out.println(<span class="string">&quot;Origin array: &quot;</span> + Arrays.toString(arr3));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + times + <span class="string">&quot; done!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test done successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-升级问题"><a href="#5-升级问题" class="headerlink" title="5. 升级问题"></a>5. 升级问题</h1><p>给定一个数组arr，其中只有一个数字出现了N次，剩余的数字都出现M次，且$1\le N&lt;M$，如果$N&#x3D;K$，那么返回这个出现K次的数，否则返回-1。</p><p>这个题目只是出现次数不一定是$K$次了，做法和上面的最优解大致相同，只是有一个小细节，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppearKTimesNumber3</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findKTimesNum</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length, i = <span class="number">0</span>, j, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] bitCnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; len; ++i) </span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span>((arr[i] &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) ++bitCnt[j];</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> bitCnt[j] % m;</span><br><span class="line">            <span class="keyword">if</span>(mod == k) ans |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mod != <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span>) &#123;<span class="comment">// 细节，如果ans是0的话，那么并不能保证arr中有0，或则0出现K次，因此必须再扫一遍</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> n: arr)</span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>) ++cnt;</span><br><span class="line">            <span class="keyword">if</span>(cnt != k) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间空间复杂度和上面的最优解一样</p><h1 id="6-升级问题测试程序"><a href="#6-升级问题测试程序" class="headerlink" title="6. 升级问题测试程序"></a>6. 升级问题测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppearKTimesNumberTest2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxM = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(times-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> r.nextInt(maxM) + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt(m - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mTime</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">realK</span> <span class="operator">=</span> r.nextInt(<span class="number">2</span>) == <span class="number">0</span> ? k + <span class="number">1</span> : k;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> m * mTime + realK;</span><br><span class="line">            <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[size], arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mTime; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">                <span class="keyword">while</span>(set.contains(num)) num = r.nextInt();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; m; ++x) &#123;</span><br><span class="line">                    arr1[j] = arr2[j] = arr3[j] = num;</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">            <span class="keyword">while</span>(set.contains(num)) num = r.nextInt();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; realK; ++x) &#123;</span><br><span class="line">                arr1[j] = arr2[j] = arr3[j] = num;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> AppearKTimesNumber.findKTimesNum(arr1, k, m);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> AppearKTimesNumber3.findKTimesNum(arr2, k, m);</span><br><span class="line">            <span class="keyword">if</span>(ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Oops!, wrong answer, ans1 = &quot;</span> + ans1 + <span class="string">&quot;, ans2 = &quot;</span> + ans2 + <span class="string">&quot;, k = &quot;</span> + k + <span class="string">&quot;, m = &quot;</span> + m + <span class="string">&quot;, realK: &quot;</span> + realK);</span><br><span class="line">                System.out.println(<span class="string">&quot;Origin array: &quot;</span> + Arrays.toString(arr3));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + times + <span class="string">&quot; done!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test done successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算小知识总结</title>
      <link href="/2022/11/21/BitOperSummary/"/>
      <url>/2022/11/21/BitOperSummary/</url>
      
        <content type="html"><![CDATA[<!-- toc --><blockquote><p>  本文转载自<a href="https://blog.csdn.net/qq_37684467/article/details/119489758">https://blog.csdn.net/qq_37684467/article/details/119489758</a></p></blockquote><h1 id="1-位运算基本介绍"><a href="#1-位运算基本介绍" class="headerlink" title="1. 位运算基本介绍"></a>1. 位运算基本介绍</h1><h2 id="1-1-位运算适用的数据类型"><a href="#1-1-位运算适用的数据类型" class="headerlink" title="1.1. 位运算适用的数据类型"></a>1.1. 位运算适用的数据类型</h2><ul><li>在Java中，位运算适用于基础数据类型中的整数类型，即<font color="green">byte，short，char，int，long </font>，引用类型，布尔类型，浮点类型不可以使用。</li><li>byte，short，char类型在使用位运算的时候会被转换为int类型（符号位扩展），其结果也是int类型（表达式中没有long）；</li><li>含有long类型的位运算的表达式的结果是long类型</li></ul><p>我这里就不一一验证了哈。</p><h2 id="1-2-位运算介绍"><a href="#1-2-位运算介绍" class="headerlink" title="1.2. 位运算介绍"></a>1.2. 位运算介绍</h2><p>在说位运算之前，我们先看一下逻辑运算，逻辑运算是离散数学中的概念，我们在高中的时候应该也学过，或，且，非等运算，举两个例子：</p><ul><li>逻辑与，a且b，它的结果是，一假则假，a，b只要有一个是假，结果就是假的，否则是真</li><li>逻辑或，a或b，它的结果是，一真则真，a，b只要有一个是真，结果就是真的，否则是假</li></ul><p>位运算跟逻辑运算是相通的，把每一位的0看作假，1看作真，在这样的基础上进行的逻辑运算。因此，</p><ul><li>按位与（&amp;），如果两位都是1，结果是1，否则是0；</li><li>按位或（|），如果两位都是0，结果是0，否则是1；</li><li>按位取反（~），如果某一位是1，结果是0，否则结果是1；</li><li>按位异或（^），如果两位代表的数值一样，则结果是0，否则是1。</li><li>左移操作，a&lt;&lt;m，表示把整数a，左移m位，m可以是任何整数类型，可以是0，负整数，正整数<ul><li>当m等于0时，相当于什么也没做</li><li>当a是int类型时，（byte，char，short会自动扩展成int）<ul><li>m大于0，且m小于32，相当于把a按位左移m位，低位补0，高位舍去。</li><li>m大于等于32，int类型4字节，32位，左移32位，相当于啥也没干，因此当m大于32时的结果，相当于a&lt;&lt;(m%32)的结果；</li><li>m小于0，且m大于-32，例如m&#x3D;-1，左移-1位，相当于左移32位时，上一次的结果，即左移31位的结果，此时结果相当于a&lt;&lt;(32+m)的结果</li><li>m小于等于-32，int类型4字节，32位，左移-32位，相当于啥也没干，因此当m小于-32时的结果，相当于a&lt;&lt;(32-(-m)%32)的结果</li></ul></li><li>当a时long类型时，只需把结论中的32换成64即可，不再赘述</li></ul></li><li>右移操作，a&gt;&gt;m，相当于把a按位右移m位，低位舍去，高位补符号位（<a href="https://blog.csdn.net/qq_37684467/article/details/114366711?spm=1001.2014.3001.5501">啥是符号位？</a>）。剩余的规则跟左移是一样的。</li><li>无符号右移，可以理解为普通的右移，只不过高位补0</li></ul><h2 id="1-3-对异或的理解"><a href="#1-3-对异或的理解" class="headerlink" title="1.3. 对异或的理解"></a>1.3. 对异或的理解</h2><p>异或规则是，如果两位代表的数值一样，则结果是0，否则是1。可以理解为什么呢？可以理解为，如果两个位中1的个数是偶数，则结果为0，否则结果为1。<br><img src="https://img-blog.csdnimg.cn/111e47a071504ca3a615d3c55bb2e488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>既然，异或可以这么理解，那么多个数同时异或的时候，异或的结果假设为ans，即<br><code>a1 ^ a2 ^ a3 ^.....an = ans</code><br><strong>那ans的每一位，都是所有的数在这一位上的1的个数的奇偶性决定的，如果所有的数在这一位上1的个数加起来是奇数，那ans的这一位就是1，否则是0。<br>而结果中1的个数的奇偶性，跟异或的顺序是没有关系的，不可能说，a1和a3先异或，就会导致结果不一样，因此异或操作满足交换律和结合律。</strong></p><p>有几个显而易见的小结论：</p><ol><li>当一个数和自己异或的时候，a^a &#x3D; 0，</li><li>一个数和0异或的时候，a^0 &#x3D; a；</li><li>当一个数和-1异或的时候，a^-1 &#x3D; ~a,</li></ol><p>那异或还可以理解为什么呢？<br>可以理解为无进位相加，a^b相当于a和b按位无进位相加，无进位相加，就是按照加法的规则，一位一位的相加，只不过，不考虑进位；<br><img src="https://img-blog.csdnimg.cn/17689b71e6c74f42a109d72204d449fd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>那a+b的结果相当于a和b无进位相加的结果，加上进位信息</strong>，进位信息怎么算？<br>啥时候产生进位？？，只有两位都是1的时候会产生，因此a和b的进位信息就是(a&amp;b)&lt;&lt;1，为啥左移一位？因为进位是向上进位的。因此可以使用位运算实现加法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        t = a;<span class="comment">//t 先抓住上一次的a</span></span><br><span class="line">        a ^= b;<span class="comment">// a保留a和b无进位相加的结果</span></span><br><span class="line">        b = (b &amp; t) &lt;&lt; <span class="number">1</span>;<span class="comment">//b和原来的a相与，保留进位信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-位运算应用"><a href="#2-位运算应用" class="headerlink" title="2. 位运算应用"></a>2. 位运算应用</h1><h2 id="2-1-快速乘法"><a href="#2-1-快速乘法" class="headerlink" title="2.1. 快速乘法"></a>2.1. 快速乘法</h2><p>a*b，当b是2的n次幂时，即$b &#x3D;2^n$，a*b &#x3D; a&lt;&lt;n;</p><h2 id="2-2-快速除法"><a href="#2-2-快速除法" class="headerlink" title="2.2. 快速除法"></a>2.2. 快速除法</h2><p>$\frac{a}{b}$，当b是2的n次幂时，即$b &#x3D;2^n$，$\frac{a}{b}$ &#x3D; a&gt;&gt;n;</p><h2 id="2-3-快速取模"><a href="#2-3-快速取模" class="headerlink" title="2.3. 快速取模"></a>2.3. 快速取模</h2><p>a%b，当b是2的n次幂时，即$b &#x3D;2^n$，a%b &#x3D; a&amp;(b-1)；为啥，因为$b &#x3D;2^n$，因此b的二进制中，第$n$位为1，而$b-1 &#x3D;\frac{1-2^n}{1-2}&#x3D;2^0+2^1+2^2+…+2^{n-1}$（等比数列求和），相当于把第n位置0，后面的所有位都置1。<br><img src="https://img-blog.csdnimg.cn/f0d609208dde443db97bf9526c160695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>而a%b不就是，a中去掉几个x个b，剩下不够一个b的部分吗？如果a&lt;b，那么a&lt;&#x3D;b-1，a和全都是1的部分相与，那结果显然正确；如果a&gt;b，那a至少第n位是1，有可能第n+1位，第n+2位是1，但是这些位代表的数，都是b的整倍数，剩下不足一个b的部分，就是a的低n-1位组成的数，才是余数，所以取a的低n-1位就是结果。<br><img src="https://img-blog.csdnimg.cn/6cc471c739f4408397ff916d0480726b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="2-4-对称加密"><a href="#2-4-对称加密" class="headerlink" title="2.4. 对称加密"></a>2.4. 对称加密</h2><p>对于两个整数a，b，如果 a &#x3D; a^b，此时a成了a和b异或的结果，a此时再次异或b，a &#x3D; a^b^b &#x3D; a^0 &#x3D; a，又变回了a，此时b相当于一个对称密钥的作用。</p><h2 id="2-5-两数交换"><a href="#2-5-两数交换" class="headerlink" title="2.5. 两数交换"></a>2.5. 两数交换</h2><p>不使用额外变量交换两个数，直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    a ^= b; <span class="comment">//此时 a的值是 a^b</span></span><br><span class="line">    b ^= a; <span class="comment">// b = (a^b) ^b  = a;</span></span><br><span class="line">    a ^= b; <span class="comment">// a = (a^b) ^a(b已经变成a了)  = b;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果交换的是数组元素，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">        arr[i] ^= arr[j];</span><br><span class="line">        arr[j] ^= arr[i];</span><br><span class="line">        arr[i] ^= arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异或的两个元素不能同时指向同一块内存，否则这个内存的数变成0</p><h2 id="2-6-位图（bitmap）"><a href="#2-6-位图（bitmap）" class="headerlink" title="2.6. 位图（bitmap）"></a>2.6. 位图（bitmap）</h2><p>假设需要实现一个集合，可以往集合中放入自然数，然后判断一个数是不是存在于集合中，我们可以使用hash表实现，当数的范围比较集中的时候，我们可以使用一个bit位是0或1表示这个数是否在集合中。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] data;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max bitmap能保存的最大自然数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BitMap</span><span class="params">(<span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;max number can not less than zero&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">int</span>[(max + <span class="number">31</span>) &gt;&gt; <span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; max) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;number can not greater than max&quot;</span>);</span><br><span class="line">        <span class="comment">// 先找到这个数应该存在哪个整数里，粗略定位</span></span><br><span class="line">        <span class="comment">// 再确定这个数在哪一位上</span></span><br><span class="line">        <span class="comment">//然后把这一位置1</span></span><br><span class="line">        data[number &gt;&gt; <span class="number">5</span>] |= (<span class="number">1</span> &lt;&lt; (number &amp; <span class="number">31</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; max) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;number can not greater than max&quot;</span>);</span><br><span class="line">        data[number &gt;&gt; <span class="number">5</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (number &amp; <span class="number">31</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; max) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;number can not greater than max&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (data[number &gt;&gt; <span class="number">5</span>] &amp; (<span class="number">1</span> &lt;&lt; (number &amp; <span class="number">31</span>))) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-确定一个int整数中有几个位是1"><a href="#2-7-确定一个int整数中有几个位是1" class="headerlink" title="2.7. 确定一个int整数中有几个位是1"></a>2.7. 确定一个int整数中有几个位是1</h2><p><strong>解法1：</strong> 依次测试每一位是0 还是1，然后设置一个计数器，当前位是1，则计数器加一，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countOneBit</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) </span><br><span class="line">        <span class="keyword">if</span> ((number &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) ++ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法2：</strong> 解法1遍历的次数固定32次，还有更好的方法吗？有<br>下面我们先看一下，假设一个数x不是0，x-1的二进制表示与x的二进制表示有什么不同？？？<br>其实是这样的，因为x不是0，因此不妨假设从低位开始数，x的第一个非0的位在第$n$($0&lt;&#x3D;n&lt;&#x3D;31$)位，那么x和-1相加，相当于把前低n位全部取反，剩余的，同时第n位和1相加，产生一个进位，导致后面的位和1相加以后，都没有发生改变。如下图所示：<br><img src="https://img-blog.csdnimg.cn/10721fd8859c4f9cb9b5e3a37cea3142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>x-1的结果，<strong>就是把x最右边的1及其前面的位都取反了</strong>，那x&amp;(x-1)，相当于，把x最右边的1置0，那么我们设置一个计数器，每一次把x最右边的1置0，然后计数器加一，直到x变成0为止，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countOneBit</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">        number &amp;= (number - <span class="number">1</span>);</span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环次数是，number中有几个1，就循环几次。</p><p><strong>解法3：</strong>  有没有更好的做法？有，请往下看。<br>这种做法的思路是，先两位分组，把两位中1的数量找出来，还放到这两位中，如下图所示：<br><img src="https://img-blog.csdnimg.cn/0db32219ebdf42d1b1eb012573e41b89.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>那如何做到这一步呢？两位二进制，一共四种情况，我们分别列出来看一下，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/6f12316d687c467f9458cd4ab820da2e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>假设这个数是x，我们可以把x无符号右移一位，然后使用原来的x减去它，即x-(x&gt;&gt;&gt;1)；这样做并不可行，因为是整体无符号右移，不是两位一组的无符号右移，这样移动会导致下一组的最低位，移到这一组的最高位，如果这一位是0那道无所谓，如果是1，就影响计算了，因此，我们需要把x&gt;&gt;&gt;1的值中所有的偶数位置0，因此只需要让它跟<code>0x55555555</code>相与即可，如下图所示：<br><img src="https://img-blog.csdnimg.cn/8a7d9f8411c14b2bb8b5181b5a5b4e73.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>经过这一步，已经完成了两位一组的，把1的个数找出来，并存储在这两位当中了，接下来，就是4位一组，8位一组，16位一组进行合并即可。</p><p>四位一组进行合并，我们需要四位一组的高两位和低两位相加，我们把上一步得到的结果，记作x，我们让x无符号右移两位，这样，高两位和低两位对齐了，不要忘记清除垃圾数据，因此右移的过程中，下一组的低两位，会移动到当前组的高两位上，影响计算结果，因此计算之前，清除高两位的值，如下图所示：<br><img src="https://img-blog.csdnimg.cn/321404b240ce45eebb110e1ab53dcd4f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>八位一组进行合并，跟四位一组合并类似，也是需要移位，把最高位置0，下面不再赘述，当16位一组合并完成后，因为int类型有32位，1的个数不会超过2的5次方，所以取结果的低6位即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countOneBit</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    number -= ((number &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    number = (number &amp; (<span class="number">0x33333333</span>)) + ((number &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    number = (number + (number &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    number += number &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    number += number &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> number &amp; <span class="number">0x3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实是jdk中bitCount方法的实现。</p><h2 id="2-8-判断一个数是不是2的幂"><a href="#2-8-判断一个数是不是2的幂" class="headerlink" title="2.8. 判断一个数是不是2的幂"></a>2.8. 判断一个数是不是2的幂</h2><p>如果一个整数是2的幂（如果是负数的话，说他的绝对值），那么它的二进制表示中只有1个位是1，我们只需要把它最右边的1置0，然后判断是否为0即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOf2</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    number = Math.abs(number);</span><br><span class="line">    <span class="keyword">return</span> (number &amp; (number - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-9-取一个数二进制表示中最右边的1表示的数"><a href="#2-9-取一个数二进制表示中最右边的1表示的数" class="headerlink" title="2.9. 取一个数二进制表示中最右边的1表示的数"></a>2.9. 取一个数二进制表示中最右边的1表示的数</h2><p>意思就是，例如12的二进制表示为<code>0000 1100</code>，取出最右边的1代表的数，<code>0000 0100</code>，即4，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightOneBit</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number &amp; ((~number) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>number取反+1，相当于把number的最右边的1及其右边的0（如果存在的话）保留下来，最后边的1左边的位全部取反了，然后相与，就把最后边的1留下来了。<br><img src="https://img-blog.csdnimg.cn/69efd902f0a846aeb68e6cb9ea3a5f06.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><code>(~number) + 1</code>其实就是-number，可以简单记为<code>number&amp;-number</code></p><h2 id="2-10-取一个数二进制表示中最左边的1表示的数"><a href="#2-10-取一个数二进制表示中最左边的1表示的数" class="headerlink" title="2.10. 取一个数二进制表示中最左边的1表示的数"></a>2.10. 取一个数二进制表示中最左边的1表示的数</h2><p>这里只针对正整数x，例如12的二进制表示为<code>0000 1100</code>，取出最左边的1代表的数，<code>0000 1000</code>，即8，就是找到不超过x的最大的2的幂。例如给个7，返回4，给个9返回8，给个8返回8。<br>此时我们不知道最左边的1在哪个位置，其实方法就是我们把这个数，最左边的1右边全变成1，例如12，<code>0000 1100</code>，我们想办法变成<code>0000 1111</code>，这样我们把这个数+1，然后右移一位即可。如何做到把最左边的1右边全变成1呢？其实我们可以把x和(x&gt;&gt;&gt;1)按位或，这样，最左边的1和次左边的位都变成1，然后右移两位，再次或，然后右移四位，八位，16位，代码如下：<br><img src="https://img-blog.csdnimg.cn/8f00cdaaf31c4408a5d8b78d13a75402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3Njg0NDY3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftOneBit</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((number &amp; (number - <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> number;</span><br><span class="line">    number |= number &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    number |= number &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    number |= number &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    number |= number &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    number |= number &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (number + <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-11-找出大于等于一个数的最小的2的幂"><a href="#2-11-找出大于等于一个数的最小的2的幂" class="headerlink" title="2.11. 找出大于等于一个数的最小的2的幂"></a>2.11. 找出大于等于一个数的最小的2的幂</h2><p>例如给一个5，大于等于5的最小的2的幂是8，因此返回8，给3，返回4，给8，返回8。<br>其实，这个数值，就是上一个问题《取一个数二进制表示中最左边的1表示的数》，在最后不要右移一位的值，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftOneBit</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((number &amp; (number - <span class="number">1</span>)) == <span class="number">0</span>) <span class="keyword">return</span> number;</span><br><span class="line">    number |= number &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    number |= number &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    number |= number &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    number |= number &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    number |= number &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span>;<span class="comment">//这里不要右移一位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-12-只出现一次的数字"><a href="#2-12-只出现一次的数字" class="headerlink" title="2.12. 只出现一次的数字"></a>2.12. 只出现一次的数字</h2><p><a href="https://leetcode-cn.com/problems/single-number/">leetcode第136题</a>，异或有两个性质</p><ol><li>相同的两个数异或为0</li><li>0跟任何数异或是自己</li></ol><p>因此，我们可以用0，跟数组中的所以数异或一次，相同的两个数必然两两异或变为0，剩下的那个数即为所求，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums)ans^=i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>升级版题目：给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。<a href="https://leetcode-cn.com/problems/single-number-iii/">leetcode260题</a><br>假设那两个数是a，b。我们按照第一道题的做法，把所有元素异或一遍，得到的值肯定是a^b的结果（记作res），且不为0，我们如何把这两个数拆分出来呢？<br>思路这样：<strong>res的结果不为0，则肯定某一位是1，我们不妨取res的最右边的1，那么a和b必然在这一位上一个是0，一个是1，我们把数组中这一位是1的所有数组挑出来再次异或一遍，最后得到的结果肯定就是a和b中的一个，记作ans，再把ans和res异或，得到另一个。</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) res ^= n;</span><br><span class="line">    <span class="type">int</span> <span class="variable">masker</span> <span class="operator">=</span> res &amp; (~res + <span class="number">1</span>), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) </span><br><span class="line">        <span class="keyword">if</span> ((n &amp; masker) != <span class="number">0</span>) ans ^= n;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;ans, res ^ ans&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上内容如有错误，码字仓促，请大家不吝赐教。OK，今天的内容据到这里啦，下期再见，拜拜。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top K问题</title>
      <link href="/2022/11/17/TopK/"/>
      <url>/2022/11/17/TopK/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>给定一个数组，找出数组中最大的K个元素，按照从小到大的顺序返回。保证K不超过数组的长度。</p><h1 id="2-使用排序的方法"><a href="#2-使用排序的方法" class="headerlink" title="2.使用排序的方法"></a>2.使用排序的方法</h1><p>把数组按照从小到大的顺序排序，然后取最后的K个元素即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKUsingSort</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topK(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length, i;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 排序后取最后的K个数即可。</span></span><br><span class="line">        <span class="keyword">for</span>(i = len - k; i &lt; len; ++i) ans[i - len + k] = arr[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，空间复杂度$O(1)$。</p><h1 id="3-使用堆数据结构"><a href="#3-使用堆数据结构" class="headerlink" title="3. 使用堆数据结构"></a>3. 使用堆数据结构</h1><h2 id="3-1-使用大根堆"><a href="#3-1-使用大根堆" class="headerlink" title="3.1. 使用大根堆"></a>3.1. 使用大根堆</h2><p>方法是先通过heapIfy把数组调整成一个大根堆，然后从堆中弹出K个元素即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKUsingBigRootHeap</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topK(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length, i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把数组调整成大根堆</span></span><br><span class="line">        <span class="keyword">for</span>(i = (len &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt; -<span class="number">1</span>; --i) heapIfy(arr, i, len);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; ++i) &#123;<span class="comment">// 弹出K次堆顶</span></span><br><span class="line">            ans[k - i - <span class="number">1</span>] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[--len];</span><br><span class="line">            heapIfy(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapIfy</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> index, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">int</span> child, value = heap[index], bnd =  size &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; bnd) &#123;</span><br><span class="line">            child = (index &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(child + <span class="number">1</span> &lt; size &amp;&amp; heap[child] &lt; heap[child + <span class="number">1</span>]) ++child;</span><br><span class="line">            <span class="keyword">if</span>(value &gt;= heap[child]) <span class="keyword">break</span>;</span><br><span class="line">            heap[index] = heap[child];</span><br><span class="line">            index = child;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度，数组调整成大根堆的时间是$O(N)$，弹出K次堆顶元素$O(K\log_2N)$，所以时间复杂度$O(N+K\log_2N)$。空间复杂度$O(1)$（如果不允许修改原数组的话，那么就需要$O(N)$的额外空间）。当K较小的时候，时间复杂度还是可以接受的。</p><h2 id="3-2-使用小根堆"><a href="#3-2-使用小根堆" class="headerlink" title="3.2. 使用小根堆"></a>3.2. 使用小根堆</h2><p>我们维护一个长度为K的小根堆，然后遍历数组，当堆不满的时候，元素进入堆，当堆满的时候，如果当前元素比堆顶大，那么当前元素替换堆顶，否则丢弃当前元素。数组遍历完的时候，堆中的元素就是最大的K个数了，把堆中的元素依次弹出即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKUsingSmallRootHeap</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topK(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, ans, <span class="number">0</span>, k);</span><br><span class="line">        <span class="type">int</span> i, len = arr.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把前K个元素，调整成小根堆</span></span><br><span class="line">        <span class="keyword">for</span>(i = (k &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt; -<span class="number">1</span>; --i) heapIfy(ans, i, k);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历数组后面的元素， 如果比堆顶大，则替换堆顶</span></span><br><span class="line">        <span class="keyword">for</span>(i = k; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[<span class="number">0</span>] &lt; arr[i]) &#123;</span><br><span class="line">                ans[<span class="number">0</span>] = arr[i];</span><br><span class="line">                heapIfy(ans, <span class="number">0</span>, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ans);<span class="comment">// 最后对答案排序</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapIfy</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> index, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> heap[index], child, bnd = size &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; bnd) &#123;</span><br><span class="line">            child = (index &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(child + <span class="number">1</span> &lt; size &amp;&amp; heap[child] &gt; heap[child + <span class="number">1</span>]) ++child;</span><br><span class="line">            <span class="keyword">if</span>(v &lt;= heap[child]) <span class="keyword">break</span>;</span><br><span class="line">            heap[index] = heap[child];</span><br><span class="line">            index = child;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[index] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度，调整小根堆$O(K)$，剩余部分数组遍历和调整堆$O((N-K)\log_2K)$，最后对答案数组排序$O(K\log_2K)$；因此总的时间就是$O(K+(N-K)\log_2K+K\log_2K) &#x3D; K+N\log_2K$。空间复杂度$O(1)$。当N很大，甚至无限的时候，这个方法也可以适用。</p><h1 id="4-使用快速排序的划分过程"><a href="#4-使用快速排序的划分过程" class="headerlink" title="4. 使用快速排序的划分过程"></a>4. 使用快速排序的划分过程</h1><p>可以利用快速排序的划分过程，找到数组中第K大的元素target，然后遍历一次数组，找大于target的元素放入答案数组，再次遍历，找等于target的元素放入答案数组，最后对答案数组排序即可。那么如何使用快排的partition过程，找出数组中第K大的元素呢？</p><blockquote><p>不能只遍历一次，找大于等于target的元素。这是因为，例如数组arr&#x3D;[1,1,1,1,1,1,1,1,2] , K &#x3D; 2 的时候</p><p>我们通过数组划分，找到第2大的元素是1，如果我们遍历数组一次，找大于等于1的元素，会得到[1,1]这样的答案，而不是[1,2]。</p></blockquote><p>我们通过数组划分，选择一个枢轴元素pivot，如果划分以后，</p><ol><li>大于枢轴部分的长度是K-1的话，那么说明，枢轴就是第K大的元素；</li><li>如果大于枢轴部分的长度大于等于K的话，那么说明大于枢轴部分包含了第K大的元素，因此我们需要在大于部分中寻找第K大的元素；</li><li>如果大于枢轴部分的长度$len_{big}$小于K-1，那么此时需要看等于枢轴部分的长度$len_{equ}$，<ol><li>如果$len_{big}+len_{equ}&gt;&#x3D;K$，那么枢轴元素就是第K大的元素；</li><li>如果$len_{big}+len_{equ}&lt;K$，那么说明第K大的元素在小于枢轴的部分，于是我们需要在小于部分寻找第$K - len_{big}-len_{equ}$大的元素。</li></ol></li></ol><p>对于枢轴元素的选取可以采用随机法和三数取中法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKUsingArrayPartition</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topK(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>, e = arr.length - <span class="number">1</span>, len, kThbig = arr[s], ansLen = k;</span><br><span class="line">        <span class="keyword">while</span>(s &lt;= e) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s == e) &#123; <span class="comment">// 如果只有一个数，那么这个数就是答案</span></span><br><span class="line">                kThbig = arr[s];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len = e - s + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 三数取中选取枢轴</span></span><br><span class="line">            <span class="type">int</span> pivotIndex;</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">2</span>) pivotIndex = s;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (s + e) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                pivotIndex = arr[s] &gt; arr[mid] ? ((arr[mid] &gt; arr[e] ? mid : (arr[s] &gt; arr[e] ? e : s))) : (arr[s] &gt; arr[e] ? s : (arr[mid] &gt; arr[e] ? e : mid));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 三数取中选取枢轴</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 荷兰国旗问题</span></span><br><span class="line">            swap(arr, pivotIndex, e);</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s - <span class="number">1</span>, r = e, i = s, pivotValue = arr[e];</span><br><span class="line">            <span class="keyword">while</span>(i &lt; r) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &lt; pivotValue) swap(arr, ++l, i++);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; pivotValue) swap(arr, --r, i);</span><br><span class="line">                <span class="keyword">else</span> ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, e, r);</span><br><span class="line">            <span class="comment">// 荷兰国旗问题</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(e - r == k - <span class="number">1</span>) &#123;<span class="comment">//大于区域刚好是k-1长度，那么枢轴就是答案</span></span><br><span class="line">                kThbig = pivotValue;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(e - r &gt;= k) s = r + <span class="number">1</span>;<span class="comment">//大于区域刚长度至少是k，那么就在大于区域找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(e - r &lt; k - <span class="number">1</span>) &#123; <span class="comment">// 否则大于区域长度不超过k-1</span></span><br><span class="line">                <span class="keyword">if</span>(e - l &gt;= k) &#123;<span class="comment">// 如果等于区域+大于区域长度至少是k，那么枢轴就是答案</span></span><br><span class="line">                    kThbig = pivotValue;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                k -= e - l;<span class="comment">// 否则，在小于区域找</span></span><br><span class="line">                e = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        len = arr.length;</span><br><span class="line">        <span class="comment">// 两次遍历，找到top k的数</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; kThbig) ans[j++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == kThbig) ans[j++] = arr[i];</span><br><span class="line">            <span class="keyword">if</span>(j == ansLen) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != j &amp;&amp; arr[i] != arr[j]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N+K\log_2K)$，空间复杂度$O(1)$。这个时间复杂度是平均值，当枢轴选取的每次都很不合理的时候，也会使得时间复杂度提高到$O(N^2)$（虽然这种情况很少出现，但是还是有机会出现的）。</p><h1 id="5-BFPRT算法"><a href="#5-BFPRT算法" class="headerlink" title="5. BFPRT算法"></a>5. BFPRT算法</h1><p>bfprt算法是一种线性选择算法，它的作用就是找数组中第K大，或者第K小的数。这个方法的大体思路和快速排序一样，也是基于数组的划分，只不过bfprt算法在选取枢轴值的时候的方法不同，使得最坏情况的时间复杂度能收敛到$O(N)$。下面介绍这种方法。</p><ol><li>首先对数组5个数为一组分组；</li><li>对每一个小组排序，找到每一个小组的中位数，这些中位数组成新的数组median；</li><li>递归使用bfprt算法找到median的中位数，用这个数作为枢轴元素；</li><li>使用找到的枢轴元素作为划分的基准，划分数组；</li><li>根据划分出的大于区域，等于区域，小于区域的长度和K的关系（这个关系在上面的快排方法中），递归调用bfprt算法求解。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKUsingBfprt</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topK(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">kTh</span> <span class="operator">=</span> bfprt(arr, k, <span class="number">0</span>, len - <span class="number">1</span>);<span class="comment">// 使用bfprt算法求解得到第K大的数</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; kTh) ans[j++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == kTh) ans[j++] = arr[i];</span><br><span class="line">            <span class="keyword">if</span>(j == k) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bfprt</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123; <span class="comment">// 在数组arr[l..r]上，找出第K大的数</span></span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> arr[r];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5个数一组，找出每一组的中位数，组成新的数组</span></span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[(r - l) / <span class="number">5</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j, m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= r) &#123;</span><br><span class="line">            j = Math.min(r, i + <span class="number">4</span>);</span><br><span class="line">            Arrays.sort(arr, i, j + <span class="number">1</span>);</span><br><span class="line">            help[m++] = arr[(i + j) &gt;&gt;&gt; <span class="number">1</span>];</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5个数一组，找出每一组的中位数，组成新的数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归找出中位数的中位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> bfprt(help, help.length &gt;&gt; <span class="number">1</span>, <span class="number">0</span>, help.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归找出中位数的中位数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//荷兰国旗问题划分数组</span></span><br><span class="line">        i = l - <span class="number">1</span>;</span><br><span class="line">        j = r + <span class="number">1</span>;</span><br><span class="line">        m = l;</span><br><span class="line">        <span class="keyword">while</span>(m &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[m] &lt; pivot) swap(arr, ++i, m++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[m] &gt; pivot) swap(arr, --j, m);</span><br><span class="line">            <span class="keyword">else</span> ++m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//荷兰国旗问题划分数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(r - j + <span class="number">1</span> == k - <span class="number">1</span>) <span class="keyword">return</span> pivot;</span><br><span class="line">        <span class="keyword">if</span>(r - j + <span class="number">1</span> &gt;= k) <span class="keyword">return</span> bfprt(arr, k, j, r);</span><br><span class="line">        <span class="keyword">if</span>(r - i &gt;= k) <span class="keyword">return</span> pivot;</span><br><span class="line">        <span class="keyword">return</span> bfprt(arr, k - r + i, l, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != j &amp;&amp; arr[i] != arr[j]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bfprt算法的时间复杂度问题"><a href="#bfprt算法的时间复杂度问题" class="headerlink" title="bfprt算法的时间复杂度问题"></a>bfprt算法的时间复杂度问题</h2><p>假设数组长度是$N$，每5个数为一组，每一组中的中位数组成的新数组median的长度是$\frac{N}{5}$，假设median的中位数是$p$，那么在median中至少有$\frac{N}{10}$的数不小于$p$，又因为median中的每一个数，都是原数组中5个数一组的中位数，那么可以知道，在原数组中至少有$\frac{3N}{10}$的数不小于$p$，这就可以说明，我们使用$p$作为枢轴元素划分数组后，至少可以排除掉$\frac{3N}{10}$的元素。如下图所示：</p><img src="https://pic1.zhimg.com/80/v2-2906586aaabead596cb7434a3a0f5568_720w.webp"/><p>为了估计最坏情况下的时间复杂度，我们假设每次都走最坏的情况（每次只筛掉$\frac{3N}{10}$的数），假设bfprt算法的时间复杂度为$T(N)$，那么可以知道，<br>$$<br>T(N) \le O(N) + T(\frac{N}{5})+T(\frac{7N}{10})<br>$$<br>可以证明$T(N)$收敛到$O(N)$。证明过程可以参考算法导论，以及<a href="https://zhuanlan.zhihu.com/p/291206708">这篇文章</a>。</p><p>空间复杂度$O(N)$。</p><h1 id="6-测试程序"><a href="#6-测试程序" class="headerlink" title="6. 测试程序"></a>6. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxSize = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">while</span>(times-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxSize) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[][] arrays = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>][size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> r.nextInt(<span class="number">500</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) arrays[i][j] = n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt(size) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] ans1 = TopKUsingSort.topK(arrays[<span class="number">0</span>], k);</span><br><span class="line">            <span class="type">int</span>[] ans2 = TopKUsingBigRootHeap.topK(arrays[<span class="number">1</span>], k);</span><br><span class="line">            <span class="type">int</span>[] ans3 = TopKUsingSmallRootHeap.topK(arrays[<span class="number">2</span>], k);</span><br><span class="line">            <span class="type">int</span>[] ans4 = TopKUsingArrayPartition.topK(arrays[<span class="number">3</span>], k);</span><br><span class="line">            <span class="type">int</span>[] ans5 = TopKUsingBfprt.topK(arrays[<span class="number">4</span>], k);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans1[i] != ans2[i] </span><br><span class="line">                   || ans1[i] != ans3[i] </span><br><span class="line">                   || ans1[i] != ans4[i] </span><br><span class="line">                   || ans1[i] != ans5[i]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Oops!, wrong answer, k = &quot;</span> + k);</span><br><span class="line">                    System.out.println(<span class="string">&quot;ans1: &quot;</span> + Arrays.toString(ans1));</span><br><span class="line">                    System.out.println(<span class="string">&quot;ans2: &quot;</span> + Arrays.toString(ans2));</span><br><span class="line">                    System.out.println(<span class="string">&quot;ans3: &quot;</span> + Arrays.toString(ans3));</span><br><span class="line">                    System.out.println(<span class="string">&quot;ans4: &quot;</span> + Arrays.toString(ans4));</span><br><span class="line">                    System.out.println(<span class="string">&quot;ans5: &quot;</span> + Arrays.toString(ans5));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Origin arrays: &quot;</span> + Arrays.toString(arrays[<span class="number">5</span>]));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + times + <span class="string">&quot; done!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test done successfully!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> Top K </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> 快速排序 </tag>
            
            <tag> 荷兰国旗问题 </tag>
            
            <tag> BFPRT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组排序后相邻元素的最大差值问题</title>
      <link href="/2022/11/16/MaxDiffBetweenAdjacentNumAfterSort/"/>
      <url>/2022/11/16/MaxDiffBetweenAdjacentNumAfterSort/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>给定一个数组arr，计算当这个数组排序后，相邻元素的最大差值返回。</p><p>例如，arr&#x3D;[1,4,8,6,10]，它排序后是[1,4,6,8,10]。相邻元素的最大差值是1和4之间的差值（是4-1&#x3D;3），所以返回3。</p><p>数组长度范围$[2,10^6]$，数组元素范围$[-1000,1000]$。</p><h1 id="2-暴力做法"><a href="#2-暴力做法" class="headerlink" title="2. 暴力做法"></a>2. 暴力做法</h1><p>直接排序后，计算相邻元素的差值。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxDiffBetweenAdjacentNumAfterSort</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxDiff</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>, len = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; ++i) ans = Math.max(ans, arr[i] - arr[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，不考虑系统排序的空间占用的话，空间复杂度可以认为是$O(1)$。</p><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><h2 id="3-1-算法分析"><a href="#3-1-算法分析" class="headerlink" title="3.1. 算法分析"></a>3.1. 算法分析</h2><p>假设数组长度是len，我们按照大小关系，把数组元素划分到len  + 1个桶中。那么相邻的元素会出现在哪些地方呢？</p><p>显然的，在一个桶中的元素，在排序后一定是相邻的，上一个桶的最大值和下一个桶的最小值也是相邻的。那么毫无疑问，我们要找出最大的差值，我们一般是要考察所有的相邻的元素，从中找出最大的差值。对于本题目，我们有必要考察一个桶内部元素之间的差值吗？没有必要。这是因为len个元素划分到len+1个桶，根据鸽笼原理，必然存在至少一个空桶。在这个空桶的左右两边，必然存在非空桶（最小值在第一个桶，最大值在最后一个桶），假设空桶左边的第一个非空桶是leftBucket，空桶右边的第一个非空桶是rightBucket，那么rightBucket的最小值和leftBucket的最大值的差diff，由于跨桶的缘故，diff一定不会比一个桶内的差值还要小。那么意思是说，我们现在发现了一个必然存在的答案，他一定不会比一个桶内元素得到的差值还要差，那我们就不需要考虑一个桶内部元素之间的差值的问题了（因为就算求出来，也不会比diff要好，舍弃一些没有必要求解的可能性，降低时间复杂度），我们只需要考虑桶之间的差值问题。</p><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxDiffBetweenAdjacentNumAfterSort2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxDiff</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length, bucketNumber = len + <span class="number">1</span>, min = arr[<span class="number">0</span>], max = arr[<span class="number">0</span>], i, ans = <span class="number">0</span>;</span><br><span class="line">        Bucket[] buckets = <span class="keyword">new</span> <span class="title class_">Bucket</span>[bucketNumber];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bucketIndex</span> <span class="operator">=</span> getBucketIndex(max, min, arr[i], bucketNumber);</span><br><span class="line">            <span class="keyword">if</span>(buckets[bucketIndex] == <span class="literal">null</span>) buckets[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Bucket</span>(arr[i], arr[i]);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                buckets[bucketIndex].min = Math.min(buckets[bucketIndex].min, arr[i]);</span><br><span class="line">                buckets[bucketIndex].max = Math.max(buckets[bucketIndex].max, arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; bucketNumber; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre != <span class="literal">null</span>) ans = Math.max(ans, buckets[i].min - pre);</span><br><span class="line">                pre = buckets[i].max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getBucketIndex</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> value, <span class="type">int</span> bucketNumber)</span> &#123;</span><br><span class="line">        <span class="comment">// 数组的最大值是max，最小值是min，一共分bucketNumber个桶，那么value在第几号桶（编号从0开始）？</span></span><br><span class="line">        <span class="keyword">return</span> max == min ? <span class="number">0</span> : (<span class="type">int</span>)((value - min) * ((<span class="type">long</span>)bucketNumber - <span class="number">1</span>) / (max - min));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bucket</span> &#123;<span class="comment">// 对于本题目，我们只需要关注桶内的最大值和最小值即可。</span></span><br><span class="line">        <span class="type">int</span> min, max;</span><br><span class="line">        Bucket(<span class="type">int</span> mi, <span class="type">int</span> ma) &#123;</span><br><span class="line">            min = mi;</span><br><span class="line">            max = ma;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N)$，空间复杂度$O(N)$。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxDiffBetweenAdjacentNumAfterSortTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxSize = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span>(times-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxSize) + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[size], arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) arr1[i] = arr2[i] = arr3[i] = r.nextInt(<span class="number">2001</span>) - <span class="number">1000</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> MaxDiffBetweenAdjacentNumAfterSort.maxDiff(arr1);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> MaxDiffBetweenAdjacentNumAfterSort2.maxDiff(arr2);</span><br><span class="line">            <span class="keyword">if</span>(ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Oops! wrong answer, ans1 = &quot;</span> + ans1 + <span class="string">&quot;, ans2 = &quot;</span> + ans2 + <span class="string">&quot;, size = &quot;</span> + size);</span><br><span class="line">                System.out.println(<span class="string">&quot;Origin arr: &quot;</span> + Arrays.toString(arr3));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + times + <span class="string">&quot; done successfully!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test done successfully!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 排序相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 见过就会没见过就不会系列 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>需要排序的最短子数组问题</title>
      <link href="/2022/11/14/ShortestSubarrayNeedSort/"/>
      <url>/2022/11/14/ShortestSubarrayNeedSort/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>给定一个数组arr，保证只需要对其中的一个子数组排序就可以使得整个数组有序（从小到大），计算返回这个需要排序的子数组的最小长度。</p><p>例如arr&#x3D;[1,2,5,3,4,6,7]，需要排序的最短子数组是[5,3,4]，因此返回3，你也可以对[2,5,3,4,6]排序使得整个数组有序，但是它不是最短的。</p><p>数组长度len范围：$[2,10^6]$，数组元素范围：int类型的范围</p><h1 id="2-暴力做法"><a href="#2-暴力做法" class="headerlink" title="2. 暴力做法"></a>2. 暴力做法</h1><p>既然问哪个最短的子数组排序后，整个就有序了。那我们就从最短的子数组开始尝试，只要发现某个长度的子数组排序后，整个数组有序，那么就返回这个长度即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortestSubArrayNeedSort1</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minLength</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(isSortedArray(arr)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">subArraySize</span> <span class="operator">=</span> <span class="number">2</span>; subArraySize &lt;= len; ++subArraySize) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len - subArraySize; ++i) &#123;<span class="comment">// 枚举所有的子数组</span></span><br><span class="line">                System.arraycopy(arr, <span class="number">0</span>, help, <span class="number">0</span>, len);</span><br><span class="line">                Arrays.sort(help, i, i + subArraySize);</span><br><span class="line">                <span class="keyword">if</span>(isSortedArray(help)) <span class="keyword">return</span> subArraySize;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// 不可到达的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSortedArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;<span class="comment">// 检查数组是否是一个排好序的数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设数组长度是$N$，那么时间复杂度$O(N^3\log_2N)$，空间复杂度$O(N)$。</p><h1 id="2-好一点的做法"><a href="#2-好一点的做法" class="headerlink" title="2. 好一点的做法"></a>2. 好一点的做法</h1><p>排序的本质就是根据元素的大小关系，改变元素的位置。如果我们把原数组和把它排好序后的数组对比，如果相同位置上的元素不一样，那么这个位置的元素是一定要参与排序的，否则它就不能到达正确的位置上。所以我们如果找到第一个需要排序的元素的位置x，和最后一个需要排序的元素的位置y，而题目要求我们只能对一个子数组进行排序，那么x和y之间的子数组（包括端点）就需要排序，而且是最短的了（因为一定要包含x和y这两个位置）。</p><p>因此算法就很简单了，把原数组的拷贝排序，记录下来第一个不一样的位置和最后一个不一样的位置，返回这两个位置之间的长度（注意边界）。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortestSubArrayNeedSort2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minLength</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, help, <span class="number">0</span>, len);</span><br><span class="line">        Arrays.sort(help);<span class="comment">// 排序辅助数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> -<span class="number">1</span>, last = -<span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] != help[i]) &#123;<span class="comment">// 找到第一个和最后一个对不上的元素</span></span><br><span class="line">                last = i;</span><br><span class="line">                <span class="keyword">if</span>(first == -<span class="number">1</span>) first = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> last - first + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，空间复杂度$O(N)$。</p><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><p>不难想象，既然只对一个子数组排序就可以使得整个数组有序，那么必然存在最大的x和最小的y满足（$0\le x \le y \le len-1$），使得子数组arr[0..x]和子数组arr[y..len-1]是有序的，而子数组arr[x+1..y-1]是需要排序的，所以我们只要确定了x和y，问题就迎刃而解。</p><p>那么怎么确定这两个位置呢？先说怎么确定y的位置。</p><p>我们回想一下选择排序过程，选择排序是怎么把数据变有序呢？是先从arr[0..len-1]上选出一个最大的，放在len-1位置，然后从arr[0..len-2]中选择一个最大的，放在len-2位置，……，因此arr[0..len-2]上的最大值，是不超过arr[len-1]的；arr[0..len-3]上的最大值，是不超过arr[len-2]的……，那么反过来，如果我们可以依次确认arr[0..len-2]上的最大值是不超过arr[len-1]的，arr[0..len-3]上的最大值是不超过arr[len-2]的，……，arr[0..y-1]的最大值是不超过arr[y]的，那么可以证明子数组arr[y..len-1]是有序的。直到我们发现arr[0..y-2]的最大值超过了arr[y-1]，那么此时我们就找到了需要排序的子数组的右边界的位置。</p><p>那么找到x的位置也是根据类似的道理。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortestSubArrayNeedSort3</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minLength</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 在寻找排序子数组右边界的时候，我们不应该先找arr[0..len-2]的最大值，再找arr[0..len-3]的最大值，因为这样会使得时间复杂度加一阶</span></span><br><span class="line">        <span class="comment">// 我们应该先找arr[0..0]上的最大值，然后确认这个最大值是否不超过arr[1],</span></span><br><span class="line">        <span class="comment">// 再找arr[0..1]上的最大值，然后确认这个最大值是否不超过arr[2],</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 我们取最后一个index,满足arr[0..index-1]的最大值超过arr[index]</span></span><br><span class="line">        <span class="comment">// 寻找做边界也是如此</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>, y = -<span class="number">1</span>, i, len = arr.length, max, min;</span><br><span class="line">        max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; ++i) &#123;<span class="comment">// 从左向右遍历，找到右边界</span></span><br><span class="line">            <span class="keyword">if</span>(max &gt; arr[i]) y = i;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        min = arr[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(i = len - <span class="number">2</span>; i &gt; -<span class="number">1</span>; --i) &#123;<span class="comment">// 从右向左遍历，找到左边界</span></span><br><span class="line">            <span class="keyword">if</span>(min &lt; arr[i]) x = i;</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == y ? <span class="number">0</span> : y - x + <span class="number">1</span>;<span class="comment">// 如果x==y，那么说明数组原来就是有序的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N)$，空间复杂度$O(1)$。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortestSubArrayNeedSortTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxArraySize = <span class="number">99</span>;</span><br><span class="line">        <span class="keyword">while</span>(times-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxArraySize) + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="type">int</span>[] array2 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="type">int</span>[] array3 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="type">int</span>[] array4 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) </span><br><span class="line">                array1[i] = array2[i] = array3[i] = array4[i] = r.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> ShortestSubArrayNeedSort1.minLength(array1);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> ShortestSubArrayNeedSort2.minLength(array2);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans3</span> <span class="operator">=</span> ShortestSubArrayNeedSort3.minLength(array3);</span><br><span class="line">            <span class="keyword">if</span>(ans1 != ans2 || ans1 != ans3) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Oops!!! wrong answer!&quot;</span> + <span class="string">&quot; ans1 = &quot;</span> + ans1 + <span class="string">&quot;, ans2 = &quot;</span> + ans2 + <span class="string">&quot;, ans3 = &quot;</span> + ans3);</span><br><span class="line">                System.out.println(<span class="string">&quot;Origin array: &quot;</span> + Arrays.toString(array4));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + times + <span class="string">&quot; done successfully!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test done successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 排序相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 见过就会没见过就不会系列 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基数排序</title>
      <link href="/2022/11/12/RadixSort/"/>
      <url>/2022/11/12/RadixSort/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-基数排序算法思想"><a href="#1-基数排序算法思想" class="headerlink" title="1. 基数排序算法思想"></a>1. 基数排序算法思想</h1><p>现在有一个问题，对一个数组从小到大排序，数组中元素的范围都在$[0,9]$。</p><p>最好的做法是开一个数组buckets，长度为10，buckets的第i个元素，表示数字i出现的次数。因此我们只需要遍历一次数组，把各个数字出现的次数记录到buckets里，然后我们遍历buckets，如果buckets[i]&gt;0，那么就输出buckets[i]个i到元素数组即可。</p><p>写成代码就是如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortZeroToNine</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; ++i) ++buckets[arr[i]];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(buckets[j]-- &gt; <span class="number">0</span>) arr[i++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是计数排序的思想。因此当数据的范围很有限的时候（屈指可数），使用计数的思想是比较好的。</p><p>基数排序也是基于这样的想法。基数排序要求数据都是正数（如果有负数，可以通过平移的方式变成正数），排序的过程大致如下：</p><p>熟悉获取所有数中的最大值，知道最大的数是几位数。假设为r位，然后从个位数开始，直到r位，把数据按照每一位的大小排序（注意排序方法的稳定性，即相同的数字之间的原始相对位置不能改变），最后整个数组就有序了。举个例子：</p><p>假设数组arr&#x3D;[1,2,3,6,4,23,12,121]。</p><p>最大的数是121，是3位数，因此我们需要从个位到百位，每一位进行排序。</p><p>第一轮，按照个位排序：[1,121,2,12,3,23,4,6]；</p><p>第二轮，在第一轮的基础上，按照十位排序（如果没有十位，那十位上就是0）：[1,2,3,4,6,12,121,23]；</p><p>第三轮，在第二轮的基础上，按照百位排序（如果没有百位，那百位上就是0）：[1,2,3,4,6,12,23,121];</p><p>这样做为什么对呢？</p><blockquote><p>  这是因为整数的大小是由最高位决定的，当最高位相等的时候，此时我们就需要看下一位，因为我们是从低位到高位依次排序的，因此在排高位的时候，低位已经完成了排序。因为当高位相等的时候，我们只需按照数据在原数组中的原来的位置输出即可，而不能改变他们的相对次序。因为一旦改变的话，就打乱了低位已经排好的顺序（这就是为什么我们要求在给每一位排序的时候，选择的排序方法是稳定的原因）。</p><p>  即基数排序的基本思想是，高位可以决定出来大小的，就采用高位排出来的顺序，否则就采用它的下一位给出的顺序。</p><p>  例如arr&#x3D;[123,133,321]，先按个位排序：[321,123,133]，在按十位排序：[321,123,133]，再根据十位排序的时候，321和123的十位都是2，因此分不出来大小，于是就按照原顺序输出（即参考个位给出的顺序），再根据百位排序：[123,133,321]，根据百位的大小关系，321被排在了最后，这是因为它是百位最大的，于是它就改变原来的顺序（百位大的数更大，可以忽略十位排好的顺序），但是123和133因为百位都是1，分不出来大小，因此它们的相对顺序不变，从第二步的1，2位置，变成第三步的0，1位置（相对位置不变，即参考十位给出的顺序）。</p></blockquote><h1 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2. 算法实现"></a>2. 算法实现</h1><p>上面大致说了一下基数排序的流程，这里说一下对每一位排序的方法。</p><ol><li><p>在排序每一位的时候，我们需要获取到一个数x，第i（$i&gt;&#x3D;0$）位上是多少，这里可以使用一个公式获取，即$\frac{x}{10^i}\bmod 10$。</p></li><li><p>我们使计数排序的方法，对每一位排序，但是如何做到稳定性呢？</p><p>首先我们需要准备一个长度是10的数组buckets，作为计数桶，当我们遍历一遍数组以后，第i位上各个数字出现的次数信息已经收集好了。假设是如下的结果：</p><p>[1, 0, 0, 3, 1, 0, 1, 0, 0, 1]</p><p>这表示第i位上是0的出现了1次，是3的出现了3次，……，这里有一个技巧，我们把统计结果上的每一个数，都加上它的前一个数，即：[1, 1, 1, 4, 5, 5, 6, 6, 6, 7]，这个数组表示什么呢？buckets[9]上的7表示，<strong>按照第i位排好序以后，第i位上是9的最后一个数的位置，应该在原数组的buckets[9]-1（即7-1&#x3D;6）位置</strong>（buckets[9]&#x3D;&#x3D;7，代表它是原数组的第7个数，因为数组下标从0开始，所以减去1），同理buckets[3]上的4表示，第i位上是3的最后一个数，应该在4-1&#x3D;3位置……</p><p>这样我们只需要倒着遍历数组，遇到一个数的时候，查看它第i位上的数，再从buckets数组中找到这个数应该在哪个位置，然后把这个数放在相应的位置即可，然后buckets数组对应位置的数--。</p><p>这样，当我们对某一位排序完成的时候，需要从计数桶中倒出来，这样的方式可以保证倒出来后的顺序排好序且稳定的。</p><blockquote><p>  举个例子：</p><p>  假设数组arr&#x3D;[321,123,113]，现在对十位进行排序，进行一次遍历后，得到buckets数组为[0, 1, 2, 0, 0, 0, 0, 0, 0, 0]，处理后的buckets数组为[0, 1, 3, 3, 3, 3, 3, 3, 3, 3]。现在把按照十位排好序后的数组，从计数桶中倒出来，需要一个辅助数组help，</p><p>  现在倒着遍历arr数组，</p><ol><li>遇到第一个数113，它的十位是1，buckets[1] &#x3D; 1，因此我们知道，113应该放在help的1-1&#x3D;0位置，此时help&#x3D;[113, 0, 0]，同时buckets[1]--;</li><li>遇到第二个数123，它的十位是2，buckets[2] &#x3D; 3，因此我们知道，123应该放在help的3-1&#x3D;2位置，此时help&#x3D;[113, 0, 123]，同时buckets[2]--;</li><li>遇到第三个数321，它的十位是2，buckets[2] &#x3D; 2，因此我们知道，123应该放在help的2-1&#x3D;1位置，此时help&#x3D;[113, 321, 123]，同时buckets[2]--;</li></ol><p>  当我们遍历完arr的时候，就完成了倒出操作，help中的结果就是arr按照十位排好序的结果。</p></blockquote></li></ol><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] RADIX_TABLE = &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">10_0000</span>, <span class="number">100_0000</span>,</span><br><span class="line">        <span class="number">1000_0000</span>, <span class="number">1_0000_0000</span>, <span class="number">10_0000_0000</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> i, max = arr[<span class="number">0</span>], radix, j;</span><br><span class="line">        <span class="type">int</span>[] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>], data = <span class="keyword">new</span> <span class="title class_">int</span>[len], help = <span class="keyword">new</span> <span class="title class_">int</span>[len], t;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; ++i) max = Math.max(max, arr[i]);</span><br><span class="line">        radix = lengthOf(max);</span><br><span class="line">        System.arraycopy(arr, <span class="number">0</span>, data, <span class="number">0</span>, len);<span class="comment">// 这里把数据拷贝到data数组中，便于后续排序</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; radix; ++i) &#123;</span><br><span class="line">            Arrays.fill(buckets, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; len; ++j) ++buckets[radixOf(data[j], i)];<span class="comment">// 对第i位上的数，计数入桶</span></span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; ++j) buckets[j] += buckets[j - <span class="number">1</span>]; <span class="comment">//处理buckets数组，便于后续倒出</span></span><br><span class="line">            <span class="keyword">for</span>(j = len - <span class="number">1</span>; j &gt; -<span class="number">1</span>; --j) help[--buckets[radixOf(data[j], i)]] = data[j];<span class="comment">// 倒出</span></span><br><span class="line">            t = help;</span><br><span class="line">            help = data;</span><br><span class="line">            data = t;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(data, <span class="number">0</span>, arr, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOf</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">radixOf</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> i)</span> &#123;<span class="comment">// 获取num上的第i位的值，i&gt;=0</span></span><br><span class="line">        <span class="keyword">return</span> (num / RADIX_TABLE[i]) % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设数组中的最大值是max，那么时间复杂度$O(N*\log_{10}max)$，空间复杂度$O(N)$。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSortTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxArraySize = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span>(times-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxArraySize) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array2 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array3 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) array1[i] = array2[i] = array3[i] = r.nextInt(<span class="number">10_0001</span>);</span><br><span class="line">            RadixSort.sort(array1);</span><br><span class="line">            Arrays.sort(array2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(array1[i] != array2[i]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Oops!, wrong answer!!&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;array1 is:&quot;</span>);</span><br><span class="line">                    System.out.println(Arrays.toString(array1));</span><br><span class="line">                    System.out.println(<span class="string">&quot;array2 is:&quot;</span>);</span><br><span class="line">                    System.out.println(Arrays.toString(array2));</span><br><span class="line">                    System.out.println(<span class="string">&quot;origin array is:&quot;</span>);</span><br><span class="line">                    System.out.println(Arrays.toString(array3));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase &quot;</span> + times + <span class="string">&quot; is finished!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test is done successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
          <category> 基数排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基数排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2022/11/12/QuickSort/"/>
      <url>/2022/11/12/QuickSort/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1. 算法思想"></a>1. 算法思想</h1><p>快速排序整体采用分治的算法思想，先根据一个枢轴（pivot）元素把数组分成三部分，使得小于枢轴的元素在左边，等于枢轴的元素在中间，大于枢轴的元素在数组右边，这样划分相当于对数组进行了一次<strong>预排序</strong>，这是因为，等于枢轴的部分的位置在后续的排序过程中不会再动了，他们已经在了最终的位置。我们只需要对小于枢轴和大于枢轴的部分进行排序即可。</p><p>且小于枢轴的部分的元素在排序的时候，它们的位置调整仅限于小于区域内，大于枢轴的部分也是一样，相较于归并排序，我们在解决了这两个子问题以后，就不需要把两个子问题的结果进行合并。</p><h1 id="2-算法描述"><a href="#2-算法描述" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h1><p>只要待排序部分的长度大于1，那么进行下面的步骤：</p><ol><li>在待排序部分中选取一个枢轴元素pivot，按照枢轴元素，把待排序部分整理成小于枢轴的部分，等于枢轴的部分，和大于枢轴的部分</li><li>递归的对小于枢轴的部分，大于枢轴的部分进行排序。</li></ol><h2 id="2-1-枢轴元素的选取"><a href="#2-1-枢轴元素的选取" class="headerlink" title="2.1. 枢轴元素的选取"></a>2.1. 枢轴元素的选取</h2><p>枢轴元素影响了快排的时间复杂度，我们不能使用选取固定位置的元素作为枢轴（例如只选取第一个元素或者最后一个元素），这样在极端情况下（数组已经有序）会使得时间复杂度达到$O(N^2)$。比较好的方法上随机选取枢轴，或者使用三数取中法，这里我们使用三数取中法选取枢轴。</p><h2 id="2-2-荷兰国旗问题"><a href="#2-2-荷兰国旗问题" class="headerlink" title="2.2. 荷兰国旗问题"></a>2.2. 荷兰国旗问题</h2><p>荷兰国旗问题是这样描述的：</p><p>给定一段数组arr的起始位置，开始位置是s，结束位置是e，以及一个数pivot，如何把数组调整成小于pivot的部分放左边，等于pivot的放中间，大于pivot的放右边。</p><p>这里直接给出解决算法：</p><p>设置两个指针l &#x3D; s-1， r &#x3D; e+1, i &#x3D; s。</p><p>只要i&lt;r，进行下面的步骤：</p><ol><li>如果arr[i] &lt; pivot，那么把arr[i]和arr[l+1]交换，l++，i++</li><li>如果arr[i] &#x3D;&#x3D; pivot，i++；</li><li>如果arr[i] &gt; pivot，那么把arr[i]和arr[r-1]交换，r--,</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NetherlandsFlag</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> pivot)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s - <span class="number">1</span>, r = e + <span class="number">1</span>, i = s;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; pivot) swap(arr, ++l, i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; pivot) swap(arr, --r, i);</span><br><span class="line">            <span class="keyword">else</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != j &amp;&amp; arr[i] != arr[j]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N)$，空间复杂度$O(1)$。</p><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h1><h2 id="3-1-递归写法"><a href="#3-1-递归写法" class="headerlink" title="3.1. 递归写法"></a>3.1. 递归写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortRecursively</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> s, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s &gt;= e) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> e - s + <span class="number">1</span>, pivotIndex;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">2</span>) pivotIndex = s;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (s + e) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            pivotIndex = arr[s] &gt;= arr[m] ? (arr[m] &gt;= arr[e] ? m : (arr[s] &gt;= arr[e] ? e : s)) : (arr[s] &gt;= arr[e] ? s : (arr[m] &gt;= arr[e] ? e : m));<span class="comment">// 三数取中法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 荷兰国旗问题</span></span><br><span class="line">        swap(arr, pivotIndex, e);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotValue</span> <span class="operator">=</span> arr[e];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s - <span class="number">1</span>, r = e, i = s;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; r) &#123; </span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; pivotValue) swap(arr, ++l, i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; pivotValue) swap(arr, --r, i);</span><br><span class="line">            <span class="keyword">else</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, r, e);</span><br><span class="line">        <span class="comment">// 荷兰国旗问题</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*小于部分arr[s..l]，等于部分arr[l + 1..r], 大于部分arr[r + 1..e]*/</span></span><br><span class="line">        sort(arr, s, l);</span><br><span class="line">        sort(arr, r + <span class="number">1</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != j &amp;&amp; arr[i] != arr[j]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，空间复杂度$O(N\log_2N)$。</p><h2 id="3-2-迭代写法"><a href="#3-2-迭代写法" class="headerlink" title="3.2. 迭代写法"></a>3.2. 迭代写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortIteratively</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> s, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">        Stack&lt;Task&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Task&gt;();</span><br><span class="line">        st.push(<span class="keyword">new</span> <span class="title class_">Task</span>(s, e));<span class="comment">// 栈中放入初始任务</span></span><br><span class="line">        <span class="keyword">while</span>(!st.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Task</span> <span class="variable">curTask</span> <span class="operator">=</span> st.pop();</span><br><span class="line">            s = curTask.start;</span><br><span class="line">            e = curTask.end;</span><br><span class="line">            <span class="keyword">if</span>(s &gt;= e) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> e - s + <span class="number">1</span>, pivotIndex;</span><br><span class="line">            <span class="keyword">if</span>(len == <span class="number">2</span>) pivotIndex = s;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (s + e) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                pivotIndex = arr[s] &gt;= arr[m] ? (arr[m] &gt;= arr[e] ? m : (arr[s] &gt;= arr[e] ? e : s)) : (arr[s] &gt;= arr[e] ? s : (arr[m] &gt;= arr[e] ? e : m));<span class="comment">// 三数取中法</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 荷兰国旗问题</span></span><br><span class="line">            swap(arr, pivotIndex, e);</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotValue</span> <span class="operator">=</span> arr[e];</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s - <span class="number">1</span>, r = e, i = s;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; r) &#123; </span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; pivotValue) swap(arr, ++l, i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; pivotValue) swap(arr, --r, i);</span><br><span class="line">            <span class="keyword">else</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">            swap(arr, r, e);</span><br><span class="line">            <span class="comment">// 荷兰国旗问题</span></span><br><span class="line">            st.push(<span class="keyword">new</span> <span class="title class_">Task</span>(s, l)); <span class="comment">// 子任务压栈</span></span><br><span class="line">            st.push(<span class="keyword">new</span> <span class="title class_">Task</span>(r + <span class="number">1</span>, e)); <span class="comment">// 子任务压栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != j &amp;&amp; arr[i] != arr[j]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">        <span class="type">int</span> start, end;</span><br><span class="line">        Task(<span class="type">int</span> s, <span class="type">int</span> e) &#123;</span><br><span class="line">            start = s;</span><br><span class="line">            end = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，空间复杂度$O(N\log_2N)$。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxArraySize = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(time-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxArraySize) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array2 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array3 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) array1[i] = array2[i] = array3[i] = r.nextInt(<span class="number">201</span>) - <span class="number">100</span>;</span><br><span class="line">            QuickSortRecursively.sort(array1);</span><br><span class="line">            Arrays.sort(array2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(array1[i] != array2[i]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Oops! wrong answer&quot;</span>);</span><br><span class="line">                    System.out.println(Arrays.toString(array1));</span><br><span class="line">                    System.out.println(Arrays.toString(array2));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Origin array:&quot;</span>);</span><br><span class="line">                    System.out.println(Arrays.toString(array3));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase:&quot;</span> + time + <span class="string">&quot; done!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Done successfully!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
          <category> 快速排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>范围上的子数组累加和问题</title>
      <link href="/2022/11/07/SumOfArrayOnRange/"/>
      <url>/2022/11/07/SumOfArrayOnRange/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>给定一个数组array，和两个整数low，hi（$low&lt;&#x3D;hi$）,计算array中有几个子数组的累加和在范围$[low,hi]$上，返回满足条件的子数组的个数。</p><p>例如：array&#x3D;[1,3,5]，low&#x3D;3，hi&#x3D;6，那么累加和在$[3,6]$上的子数组有</p><ul><li>[3]</li><li>[5]</li><li>[1,3]</li><li>[1,5]</li></ul><p>所以返回4</p><p>数组长度len的范围$[1,100000]$，数组元素的范围$[-100,100]$</p><p>测评链接：<a href="https://leetcode-cn.com/problems/count-of-range-sum/">https://leetcode-cn.com/problems/count-of-range-sum/</a></p><h1 id="2-暴力解法"><a href="#2-暴力解法" class="headerlink" title="2. 暴力解法"></a>2. 暴力解法</h1><p>找出所有子数组，求出其累加和，然后判断是否在范围内。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumOfArrayOnRange</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumOfArrayOnRange</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, t, len = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123; <span class="comment">// 枚举子数组的开头下标</span></span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; len; ++j) &#123;<span class="comment">// 枚举子数组的结尾下标</span></span><br><span class="line">                t += array[j];</span><br><span class="line">                <span class="keyword">if</span>(t &gt;= low &amp;&amp; t &lt;= hi) ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N^2)$，空间复杂度$O(1)$。</p><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><h2 id="3-1-算法分析"><a href="#3-1-算法分析" class="headerlink" title="3.1. 算法分析"></a>3.1. 算法分析</h2><ol><li><p>使用前缀和数组加速子数组累加和的求解。</p><p>我们生成一个前缀和数组presum，presum[i]表示原数组中下标在$[0,i]$范围内的元素之和。这样当我们想求以i位置作为开头，以j位置作为结尾的子数组的累加和的时候，就可以这样求解：</p><p>当i&#x3D;&#x3D;0的时候，子数组array[i..j]的累加和就是presum[j]。</p><p>当i&gt;0的时候，子数组array[i..j]的累加和就是presum[j]-presum[i-1]。</p></li><li><p>核心思路</p><p>现在我们考虑以array[j]为结尾的子数组中有几个是满足题意的。</p><p>其开头位置设为i，那么一定有$low&lt;&#x3D;presum[j]-presum[i-1]&lt;&#x3D;hi$成立，那么可以得到presum[i-1]的范围，即$presum[j]-hi&lt;&#x3D;presum[i-1]&lt;&#x3D;presum[j]-low$，这个意思是说，只要j左边的数满足这个条件，那么我们就可以找到一个以j为结尾的子数组的累加和满足题意，特别的我们需要单独验证presum[j]是不是满足题意。</p><p>如果我们能找出以任何一个位置j作为结尾的子数组中，有几个满足题意，那么所有的结果相加就是原问题的解。</p><p>如何在一个数组中，找出一个元素左边有几个元素在范围$[presum[j]-hi,presum[j]-low]$上呢？我们可以借助merge sort的merge过程来实现。</p><p>在merge的过程中，对于右组中的任何一个数y，我们都需要找出左组有几个数x在范围$[y-hi,y-low]$上，假设我们已经求得这个答案是ans，那么我们在求解右组中下一个数$y_{next}$的答案的时候，根据右组已经有序，那么$y_{next}&gt;&#x3D;y$，那么我们知道，左组中在$[y_{next}-hi,y_{next}-low]$范围上的数不会在$y-hi$左边，那么我们在遍历左组求解答案的时候，就可以不用回退了。因为当右组中的y不断变大的时候，这个范围也是在向右平移的。</p></li></ol><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumOfArrayOnRange2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sumOfArrayOnRange</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> low, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, len = array.length, i, g = <span class="number">1</span>, l, r, m;</span><br><span class="line">        <span class="type">int</span>[] presum = <span class="keyword">new</span> <span class="title class_">int</span>[len], help = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        presum[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单独的累加和特殊处理，因为在后续的merge过程不方便处理单个的累加和数组元素</span></span><br><span class="line">        ans += array[<span class="number">0</span>] &gt;= low &amp;&amp; array[<span class="number">0</span>] &lt;= hi ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + array[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 单独的累加和特殊处理，因为在后续的merge过程不方便处理单个的累加和数组元素</span></span><br><span class="line">            ans += presum[i] &gt;= low &amp;&amp; presum[i] &lt;= hi ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(g &lt; len) &#123;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>((m = l + g - <span class="number">1</span>) &gt;= len - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                r = Math.min(len - <span class="number">1</span>, m + g);</span><br><span class="line">                ans += merge(presum, l, m, r, help, low, hi);</span><br><span class="line">                l = r + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(g &gt; (len &gt;&gt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            g &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r, <span class="type">int</span>[] h, <span class="type">int</span> low, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m + <span class="number">1</span>, ans = <span class="number">0</span>, k = <span class="number">0</span>, winL = l, winR = l;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) &#123;<span class="comment">// 对于右组的每一个位置j都要求一个答案</span></span><br><span class="line">            <span class="keyword">while</span>(winR &lt;= m &amp;&amp; array[winR] &lt;= array[j] - low) ++winR;<span class="comment">// winR 左边的，都是不超过array[j] - low的</span></span><br><span class="line">            <span class="keyword">while</span>(winL &lt;= m &amp;&amp; array[winL] &lt; array[j] - hi) ++winL;<span class="comment">// winL 左边的，都是小于array[j] - hi的</span></span><br><span class="line">            ans += winR - winL;<span class="comment">// 当计算下一个array[j]的时候，这个窗口不回退。</span></span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        j = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r) h[k++] = array[i] &lt;= array[j] ? array[i++] : array[j++];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m) h[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) h[k++] = array[j++];</span><br><span class="line">        System.arraycopy(h, <span class="number">0</span>, array, l, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，空间复杂度$O(N)$。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumOfArrayOnRangeTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxArraySize = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">while</span>(time -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxArraySize) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array2 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array3 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) array1[i] = array2[i] = array3[i] = r.nextInt(<span class="number">201</span>) - <span class="number">100</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> r.nextInt(<span class="number">1001</span>), hi = r.nextInt(<span class="number">1001</span>) + <span class="number">1000</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> SumOfArrayOnRange.sumOfArrayOnRange(array1, lo, hi), ans2 = SumOfArrayOnRange2.sumOfArrayOnRange(array2, lo, hi);</span><br><span class="line">            <span class="keyword">if</span>(ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Oops!, ans1 = &quot;</span> + ans1 + <span class="string">&quot;, ans2 = &quot;</span> + ans2);</span><br><span class="line">                System.out.println(<span class="string">&quot;lo = &quot;</span> + lo + <span class="string">&quot;, hi = &quot;</span> + hi + <span class="string">&quot;, size = &quot;</span> + size);</span><br><span class="line">                System.out.println(<span class="string">&quot;Arrays: &quot;</span>);</span><br><span class="line">                System.out.println(Arrays.toString(array3));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + time + <span class="string">&quot; finish!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Done successfully!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 归并排序相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
            <tag> 有序表 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组逆序对个数问题【2】</title>
      <link href="/2022/10/26/ReversePairCount2/"/>
      <url>/2022/10/26/ReversePairCount2/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>给定一个数组array，和一个正整数p，数组的长度len是$2^p$，再给定一个数组reverseGroup，他的数组元素的范围是$[0,p]$。我们需要返回一个答案数组ans，ans[i]表示把原数组按照$2^{reverseGroup[i]}$个元素为一组反转后，数组中逆序对的个数。</p><p>p的范围$[1,10]$，reverseGroup[i]的范围$[1,100]$。</p><p>例如：</p><p>array&#x3D;[1,2,3,4,5,6,7,8], reverseGroup &#x3D; [0,1,2], p &#x3D; 3;</p><ol><li>首先把原数组按照$2^0 &#x3D; 1$个元素一组反转，此时相当于没有反转，逆序对个数0，因此ans[0] &#x3D; 0;</li><li>然后把数组按照$2^1 &#x3D; 2$个元素为一组进行反转，反转后的数组array&#x3D;[2,1,4,3,6,5,8,7]，逆序对个数是4，ans[1] &#x3D;4，</li><li>然后把数组按照$2^2 &#x3D; 4$个元素为一组进行反转，反转后的数组array&#x3D;[3,4,1,2,7,8,5,6]，逆序对的个数是4，ans[2] &#x3D; 4,</li></ol><p>于是返回ans&#x3D;[0,4,4]；</p><h1 id="2-暴力解法"><a href="#2-暴力解法" class="headerlink" title="2. 暴力解法"></a>2. 暴力解法</h1><p>直接模拟即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReversePairCount2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] count(<span class="type">int</span>[] array, <span class="type">int</span>[] reverseGroup, <span class="type">int</span> p) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rLen</span> <span class="operator">=</span> reverseGroup.length, pre = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[rLen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rLen; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(reverseGroup[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre == -<span class="number">1</span>) pre = getReversePairCount(array);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                reverseByGroup(array, <span class="number">1</span> &lt;&lt; reverseGroup[i]);</span><br><span class="line">                pre = getReversePairCount(array);</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getReversePairCount</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i] &gt; array[j]) ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseByGroup</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> group)</span> &#123;<span class="comment">// group个元素为一组，反转数组。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = array.length, j;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">            j = i + group - <span class="number">1</span>;</span><br><span class="line">            reverseRange(array, i, j);</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseRange</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;<span class="comment">// 反转一块数组</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i++] = array[j];</span><br><span class="line">            array[j--] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N^2*rLen)$，空间复杂度$O(1)$。</p><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><h2 id="3-1-算法分析"><a href="#3-1-算法分析" class="headerlink" title="3.1. 算法分析"></a>3.1. 算法分析</h2><p>使用归并排序的merge过程，先按照两个数为一组求解所有组中的逆序对；然后按照4个数为一组求解所有组的逆序对（求解4个数为一组的逆序对的时候，需要把一组的4个数，分成左右两组，左右两组每组两个数，只考虑左右两组之间能产生多逆序对，而不要考虑左组内部有多少逆序对，右组内部有多少逆序对，这是因为左右两组内部的逆序对在上一步的时候已经求解过了），然后按照8个数为一组求解所有组的逆序对（同样，求解8个数为一组的时候，每一组分成左右两组，左右两组每组4个数，我们只需要求解左右两组之间可以产生多少逆序对），…，一直求解到按照$2^p$个数为一组的时候，逆序对的个数。</p><p>我们把每一步的答案都记录下来，根据数组长度是$2^p$，我们一共可以得到p个答案，因此数组中总的逆序对的个数就是这p个答案的加和。</p><p>为什么要这么做呢？</p><p>这是因为当反转的时候，我们没有必要去真的反转数组，只需要调整我们上面求得的答案，就可以快速获取反转后的答案。当我们要求4个数为一组反转后的答案的时候，可以知道4个数为一组反转后，它不影响我们上面求解的8个数为一组的时候的答案（因0为8个数为一组的答案是左右两组之间形成的逆序对的个数，左右组反转了（实际上左右组内的数据无论被洗牌成什么样，只会影响左右组自己组内的逆序对的个数，而不会影响左右两组之间形成的逆序对的个数），那么反转会使得4个数为一组，2个数为一组的逆序对的个数发生变化，变成了什么呢？其实反转以后，他们的逆序对的个数，就是反转之前正序对的个数，因此我们只需要求得2个数为一组，4个数为一组，…，$2^p$个数为一组的正序对，逆序对的个数就可以了。这样当发生反转的时候，例如$2^i$个数为一组进行反转，我们只需要从$2^1,2^2,…,2^i$，这些组的逆序对个数和正序对个数交换，那么就可以修正原来逆序对的答案数组，每一步的答案就是修正后的逆序对的答案数组的元素加和。</p><p>于是我们有如下算法：</p><p>设置两个答案数组reverseCountByGroup和normalCountByGroup，分别代表数组各个分组的逆序对个数和正序对个数。然后使用归并排序的方法，对数组求解逆序对和正序对的个数，把答案写在数组中。</p><p>设置答案数组ans，然后遍历reverseGroup数组，对每一个反转分组rGroup，进行如下步骤：</p><ol><li>如果rGroup&gt;0，那么对所有的i从0到rGroup-1，把reverseCountByGroup[i] 和 normalCountByGroup[i]，互换。</li><li>i从0到p-1，把reverseCountByGroup[i]累加起来，作为当前这次的答案放入ans中。</li></ol><p>例如，array&#x3D;[1,3,5,7,2,4,6,8], reverseGroup&#x3D;[1,2,0,3],</p><p>array长度len &#x3D; 8; p &#x3D; 3。</p><p>因此reverseCountByGroup和normalCountByGroup的长度是3</p><ol><li>reverseCountByGroup[0]的值是按照两个数为一组的时候，逆序对的总个数，因为两个数一组的时候，没有逆序对，因此reverseCountByGroup[0]&#x3D;0;</li><li>reverseCountByGroup[1]的值是按照4个数为一组的时候，因此第一组[1,3,5,7]，分成左右两组[1,3],[5,7]，这两组之间没有逆序对，同样[2,4,6,8]也没有逆序对。因此reverseCountByGroup[1]&#x3D;0;</li><li>reverseCountByGroup[2]的值是按照8个数为一组的时候，第一祖[1,3,5,7,2,4,6,8]，分成左右两组，左组[1,3,5,7]，右组：[2,4,6,8]，这两组之间可以产生逆序对（3,2），（5,2），（5,4），（7,2），（7,4），（7,6）。因此一共有6个，因此reverseCountByGroup[2]&#x3D;6;</li></ol><p>求解normalCountByGroup是类似的方法。因此</p><p>normalCountByGroup&#x3D;[4,4,10]</p><p>reverseCountByGroup&#x3D;[0,0,6]</p><p>reverseGroup[0] &#x3D; 1, 即两个数一组进行反转，因此我们需要把normalCountByGroup[0]和reverseCountByGroup[0]进行互换，因此normalCountByGroup&#x3D;[0,4,10]，reverseCountByGroup&#x3D;[4,0,6]，于是反转后，逆序对的总个数是4+0+6&#x3D;10</p><p>reverseGroup[1] &#x3D; 2, 即4个数一组进行反转，因此我们需要把normalCountByGroup[0…1]和reverseCountByGroup[0…1]进行互换，因此normalCountByGroup&#x3D;[4,0,10]，reverseCountByGroup&#x3D;[0,4,6]，于是反转后，逆序对的总个数是0+4+6&#x3D;10</p><p>…</p><p>剩下的也是类似的做法。</p><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReversePairCount22</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] count(<span class="type">int</span>[] array, <span class="type">int</span>[] reverseGroup, <span class="type">int</span> p) &#123;</span><br><span class="line">        <span class="type">int</span>[] reverseAns = <span class="keyword">new</span> <span class="title class_">int</span>[p], </span><br><span class="line">        normalAns = <span class="keyword">new</span> <span class="title class_">int</span>[p], </span><br><span class="line">        arrayCopy = <span class="keyword">new</span> <span class="title class_">int</span>[array.length], </span><br><span class="line">        h = <span class="keyword">new</span> <span class="title class_">int</span>[array.length], </span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">int</span>[reverseGroup.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; ++i) arrayCopy[array.length - <span class="number">1</span> - i] = array[i];</span><br><span class="line">        getReversePairCntAns(array, reverseAns, h);</span><br><span class="line">        getReversePairCntAns(arrayCopy, normalAns, h);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// 因为当reverseGroup[i]==0的时候，此时的答案可以采用上一步的答案，因此pre代表上一步的答案。当pre==-1的时候，代表上一步的答案无效。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; reverseGroup.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(reverseGroup[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; reverseGroup[i]; ++j) &#123;<span class="comment">// 如果翻转了，那么就需要下标从范围[0,reverseGroup[i] - 1]，reverseAns 和 normalAns 互换，这是因为反转了以后，正序对的个数就变成逆序对的个数。 </span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> reverseAns[j];</span><br><span class="line">                    reverseAns[j] = normalAns[j];</span><br><span class="line">                    normalAns[j] = t;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = -<span class="number">1</span>;<span class="comment">// 此时发生了反转，令上一步答案失效</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pre == -<span class="number">1</span>) &#123;<span class="comment">// 如果上一步答案失效，那么需要重新计算答案。</span></span><br><span class="line">                pre = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; p; ++j) pre += reverseAns[j];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getReversePairCntAns</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span>[] ans, <span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, m, r, i = <span class="number">0</span>, g = <span class="number">1</span>, len = array.length, t;</span><br><span class="line">        <span class="keyword">while</span>(g &lt; len) &#123;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>((m = l + g - <span class="number">1</span>) &gt;= len - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                r = Math.min(len - <span class="number">1</span>, m + g);</span><br><span class="line">                t += merge(array, l, m, r, h);</span><br><span class="line">                l = r + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i++] = t;</span><br><span class="line">            <span class="keyword">if</span>(g &gt; (len &gt;&gt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            g &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r, <span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m + <span class="number">1</span>, k = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= r &amp;&amp; array[i] &gt; array[j]) ++j;</span><br><span class="line">            ans += j - m - <span class="number">1</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        i = l;</span><br><span class="line">        j = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r) h[k++] = array[i] &lt;= array[j] ? array[i++] : array[j++];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m) h[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) h[k++] = array[j++];</span><br><span class="line">        System.arraycopy(h, <span class="number">0</span>, array, l, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组array长度N，reverseGroup数组长度是R，那么时间复杂度$O(max{p*R,N\log_2N})$，空间复杂度$O(N)$。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReversePairCount2Test</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxP = <span class="number">6</span>, maxReverseGroupSize = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(time-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> r.nextInt(maxP) + <span class="number">1</span>, size = <span class="number">1</span> &lt;&lt; p, groupSize = r.nextInt(maxReverseGroupSize) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array2 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array3 = <span class="keyword">new</span> <span class="title class_">int</span>[size],</span><br><span class="line">            group1 = <span class="keyword">new</span> <span class="title class_">int</span>[groupSize], group2 = <span class="keyword">new</span> <span class="title class_">int</span>[groupSize], group3 = <span class="keyword">new</span> <span class="title class_">int</span>[groupSize];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) array1[i] = array2[i] = array3[i] = r.nextInt(<span class="number">201</span>) - <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; groupSize; ++i) group1[i] = group2[i] = group3[i] = r.nextInt(p + <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span>[] ans1 = ReversePairCount2.count(array1, group1, p), ans2 = ReversePairCount22.count(array2, group2, p);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; groupSize; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans1[i] != ans2[i]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Oops! answer incorrect!!, ans1[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + ans1[i] + <span class="string">&quot;, ans2[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + ans2[i]);</span><br><span class="line">                    System.out.println(Arrays.toString(ans1));</span><br><span class="line">                    System.out.println(Arrays.toString(ans2));</span><br><span class="line">                    System.out.println(Arrays.toString(array3));</span><br><span class="line">                    System.out.println(Arrays.toString(group3));</span><br><span class="line">                    System.out.println(p);</span><br><span class="line">                    System.out.println(groupSize);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + time + <span class="string">&quot; done!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test done successfully !!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 归并排序相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组逆序对个数问题【1】</title>
      <link href="/2022/10/26/ReversePairCount/"/>
      <url>/2022/10/26/ReversePairCount/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>在一个数组中，如果存在两个下标i&lt;j，使得array[i] &gt; array[j]，那么称这是一个逆序对，求解数组中逆序对的个数。</p><p>例如：</p><p>array&#x3D;[1,2,3,1]，返回2，（2,1）,（3,1）</p><p>数组长度len范围$[1,5000]$。</p><p>测评链接：<a href="https://www.nowcoder.com/questionTerminal/bb06495cc0154e90bbb18911fd581df6">https://www.nowcoder.com/questionTerminal/bb06495cc0154e90bbb18911fd581df6</a></p><h1 id="2-暴力解法"><a href="#2-暴力解法" class="headerlink" title="2. 暴力解法"></a>2. 暴力解法</h1><p>遍历数组，对于每一个当下下标i，都在i的右边寻找有几个数小于array[i]，累加到答案中</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReversePairCount</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[i] &gt; array[j]) ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N^2)$，空间复杂度$O(1)$。</p><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><h2 id="3-1-算法分析"><a href="#3-1-算法分析" class="headerlink" title="3.1. 算法分析"></a>3.1. 算法分析</h2><p>在merge sort的merge过程中，假设左右两组都是从小到大有序的，如果我们发现左组中的一个数a，大于右组中的一个数b，那么可以知道右组中从开始到b的数，都是小于a的，因此我们可以在线性时间内，求得左组中的任何一个数，在右组中有几个数小于它。因此我们有如下算法：</p><p>假设左组的当前下标是i，左组的结束位置是m，右组的当前下标是j，右组的结束位置是r，设置一个变量ans记录当前merge中产生的所有逆序对的个数，只要i&lt;&#x3D;m成立，执行如下步骤：</p><ol><li>只要j&lt;&#x3D;r &amp;&amp; array[j] &lt; array[i] 成立，++j;</li><li>收集答案，此时右组中有j-m-1个数小于array[i]，ans+&#x3D;j-m-1;</li><li>++i;</li></ol><p>然后执行merge操作。</p><p>上游的排序过程累加每次merge产生的逆序对的个数。</p><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReversePairCount2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">int</span> l, m, r, g = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">while</span>(g &lt; len) &#123;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>((m = l + g - <span class="number">1</span>) &gt;= len - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                r = Math.min(len - <span class="number">1</span>, m + g);</span><br><span class="line">                ans += merge(array, l, m, r, h);</span><br><span class="line">                l = r + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(g &gt; (len &gt;&gt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            g &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r, <span class="type">int</span>[] h)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m + <span class="number">1</span>, k = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= r &amp;&amp; array[j] &lt; array[i]) ++j;<span class="comment">// 只要满足条件，j一直跳下一个</span></span><br><span class="line">            ans += j - m - <span class="number">1</span>;<span class="comment">//此时右组一共有j-m-1个元素小于array[i]</span></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        i = l;</span><br><span class="line">        j = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r) h[k++] = array[i] &lt;= array[j] ? array[i++] : array[j++];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m) h[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) h[k++] = array[j++];</span><br><span class="line">        System.arraycopy(h, <span class="number">0</span>, array, l, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，空间复杂度$O(N)$。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReversePairCountTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxSize = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">while</span>(time-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxSize) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array2 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array3 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) array1[i] = array2[i] = array3[i] = r.nextInt(<span class="number">101</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> ReversePairCount.count(array1), ans2 = ReversePairCount2.count(array2);</span><br><span class="line">            <span class="keyword">if</span>(ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Answer incorrect!, ans1: &quot;</span> + ans1 + <span class="string">&quot;, ans2: &quot;</span> + ans2);</span><br><span class="line">                System.out.println(Arrays.toString(array3));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + time + <span class="string">&quot; success!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test done successfully!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 归并排序相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二倍不及问题</title>
      <link href="/2022/10/25/TwiceNotLargeThan/"/>
      <url>/2022/10/25/TwiceNotLargeThan/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>给定一个数组，如果某一个元素x，对于它的右边的任何一个数p，只要满足2*p&lt;x，则认为此数达标，相对于x达标数的个数，记为函数$f(x)$，求数组中每一个数的f函数值的总和。</p><p>例如：array&#x3D;[1,2,3,1];</p><p>第0个数1的右边有0个满足要求，</p><p>第1个数2的右边有0个满足要求，</p><p>第2个数3的右边有1个满足要求，</p><p>最后一个数右边没有数，满足要求的数0个，</p><p>因此答案就是1。</p><p>数组长度len的范围$[1,10^6]$，数组元素范围$[-100,100]$。</p><h1 id="2-暴力解法"><a href="#2-暴力解法" class="headerlink" title="2. 暴力解法"></a>2. 暴力解法</h1><p>直接根据定义做，上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwiceNotGreater</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tng</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, len = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>((array[j] &lt;&lt; <span class="number">1</span>) &lt; array[i]) ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N^2)$，空间复杂度$O(1)$。</p><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><h2 id="3-1-算法分析"><a href="#3-1-算法分析" class="headerlink" title="3.1. 算法分析"></a>3.1. 算法分析</h2><p>在mergeSort的merge过程中，左右两组是有序的（假设从小到大），对于左组中的一个数a，我们发现右组中的一个数b，满足b*2&lt;a，那么根据右组数组有序，b前面的数都满足b*2&lt;a。因此我们可以设计如下算法：</p><p>对数组array进行merge sort，在merge的过程中，假设左组的位置下标i，左组结束位置m，右组下标j，右组结束位置r，设置一个变量ans记录merge过程中的产生的答案；只要 i&lt;&#x3D;m成立，进行如下步骤：</p><ol><li>只要 j&lt;&#x3D;r&amp;&amp; array[j] * 2 &lt; array[i] 成立，j++</li><li>收集答案，ans+&#x3D; j-m-1;</li><li>++i;</li></ol><p>然后进行数组的merge过程，最终merge方法返回ans;</p><p>上游的排序方法中收集每次merge的返回值，累加到总的答案中。</p><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwiceNotGreater2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tng</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">int</span> l, m, r,g = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">while</span>(g &lt; len) &#123;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>((m = l + g - <span class="number">1</span>) &gt;= len - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                r = Math.min(m + g, len - <span class="number">1</span>);</span><br><span class="line">                ans += merge(array, l, m, r, help);</span><br><span class="line">                l = r + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(g &gt; (len &gt;&gt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            g &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r, <span class="type">int</span>[] help)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m + <span class="number">1</span>, ans = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= r &amp;&amp; (array[j] &lt;&lt; <span class="number">1</span>) &lt; array[i]) ++j;</span><br><span class="line">            ans += j - m - <span class="number">1</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        i = l;</span><br><span class="line">        j = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r) help[k++] = array[i] &lt;= array[j] ? array[i++] : array[j++];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m) help[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) help[k++] = array[j++];</span><br><span class="line">        System.arraycopy(help,<span class="number">0</span>,array,l,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，空间复杂度$O(N)$。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwiceNotGreaterTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxArraySize = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">while</span>(time-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxArraySize) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array2 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array3 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) array1[i] = array2[i] = array3[i] = r.nextInt(<span class="number">201</span>) - <span class="number">100</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> TwiceNotGreater.tng(array1), ans2 = TwiceNotGreater2.tng(array2);</span><br><span class="line">            <span class="keyword">if</span>(ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Answer incorrect!!,  ans1: &quot;</span> + ans1 + <span class="string">&quot;, ans2: &quot;</span> + ans2);</span><br><span class="line">                System.out.println(Arrays.toString(array3));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + time + <span class="string">&quot; done!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test done successfully!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 归并排序相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组小和问题</title>
      <link href="/2022/10/25/SmallSum/"/>
      <url>/2022/10/25/SmallSum/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>在一个数组中，对于任何一个元素x，它左边（如果有的话）的所有小于它的元素之和，叫做关于元素x的小和，那么数组中所有元素的小和的累加和就是数组的小和。</p><p>现在给定一个数组array，求解数组的小和。</p><p>例如：array&#x3D;[1,3,4,3,7]；</p><p>关于第0个元素1的小和：0，这是因为他是最左边的元素；</p><p>关于第1个元素3的小和：1；</p><p>关于第2个元素4的小和：1 + 3 &#x3D; 4；</p><p>关于第3个元素3的小和：1；</p><p>关于第4个元素7的小和：1 + 3 + 4 + 3 &#x3D; 11。</p><p>因此数组的小和：0 + 1 + 4 + 1 + 11 &#x3D; 17。因此返回17。</p><p>数组长度len范围：$[1,10^6]$，数组数组每一个元素范围：$[-100,100]$。</p><p>相关测评：</p><ol><li><a href="https://www.nowcoder.com/questionTerminal/8397609ba7054da382c4599d42e494f3">https://www.nowcoder.com/questionTerminal/8397609ba7054da382c4599d42e494f3</a></li><li><a href="https://www.nowcoder.com/questionTerminal/bb06495cc0154e90bbb18911fd581df6">https://www.nowcoder.com/questionTerminal/bb06495cc0154e90bbb18911fd581df6</a></li></ol><h1 id="2-暴力做法"><a href="#2-暴力做法" class="headerlink" title="2. 暴力做法"></a>2. 暴力做法</h1><p>按照定义，对于每一个元素x，我们遍历它的左边部分，累加所有小于它的元素，求得x的小和，累加所有元素的小和即可。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallSum</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">smallSum</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &lt; array[i]) ans += array[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N^2)$，空间复杂度$O(1)$。</p><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><h2 id="3-1-算法分析"><a href="#3-1-算法分析" class="headerlink" title="3.1. 算法分析"></a>3.1. 算法分析</h2><p>转换思路，我们不要直接求解在一个数组中，一个元素x的小和是什么。而是尝试看一下这个元素x对总的小和的贡献，如果在元素x的右边，有y个元素都大于x，那么在最终的答案中，元素x会贡献y*x这么多值。在mergeSort中，左右两组合并的时候，两组是已经有序的了，这样的有序性可以加速我们的求解过程。</p><p>假设我们发现左组中的一个数a，小于了右组中的某个数b，因为右组的有序性（假设从小到大），可以知道在右组中，所有b后面的数都是大于a的，因此我们可以根据这样的有序性快速的知道，右组有几个数大于左组的a。</p><p>因此就有如下的算法：</p><p>对整个数组进行merge sort，在merge的逻辑中，左组的指针记做i，右组的指针记做j，右组的结束位置是r，左组的结束位置记做m，设置一个变量ans记录merge过程产生的小和总贡献值，只要i&lt;&#x3D;m &amp;&amp; j &lt;&#x3D; r成立，那么执行如下步骤：</p><ol><li>如果array[i] &lt; array[j]，那么array[j] 后面的数都是大于array[i]的，因此array[i]贡献了array[i] * (r-j+1)的小和，把这个数加到ans中；</li><li>否则j++；</li></ol><p>返回ans。</p><p>在mergeSort的主过程中，收到merge返回的贡献值，累加到总答案中。</p><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallSum2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">smallSum</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">group</span> <span class="operator">=</span> <span class="number">1</span>, l = <span class="number">0</span>, r = len - <span class="number">1</span>, x, m, y;</span><br><span class="line">        <span class="keyword">while</span>(group &lt; len) &#123;</span><br><span class="line">            x = l;</span><br><span class="line">            <span class="keyword">while</span>(x &lt; r) &#123;</span><br><span class="line">                <span class="keyword">if</span>((m = x + group - <span class="number">1</span>) &gt;= r) <span class="keyword">break</span>;</span><br><span class="line">                y = Math.min(m + group, r);</span><br><span class="line">                ans += merge(array,x,m,y,help);</span><br><span class="line">                x = y + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(group &gt; (len &gt;&gt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            group &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r, <span class="type">int</span>[] help)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt; array[j]) ans += array[i] * (r - j + <span class="number">1</span>);</span><br><span class="line">            help[k++] = array[i] &lt; array[j] ? array[i++] : array[j++];<span class="comment">// 相等的时候，拷贝右组，这是因为相等的时候，此时不知道右组中有几个数比array[i]要大，此时array[i]的贡献值还不能确定，如果i向下跳一个，那么如果j后面有大于array[i]的数，就错过了array[i]的贡献值了，因此只能j向下跳一个，继续比较。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m) help[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) help[k++] = array[j++];</span><br><span class="line">        System.arraycopy(help,<span class="number">0</span>,array,l,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，空间复杂度$O(N)$。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallSumTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxArraySize = <span class="number">100_0000</span>;</span><br><span class="line">        <span class="keyword">while</span>(testTimes-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxArraySize) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array2 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) array1[i] = array2[i] = r.nextInt(<span class="number">201</span>) - <span class="number">100</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ans1</span> <span class="operator">=</span> SmallSum.smallSum(array1), ans2 = SmallSum2.smallSum(array2);</span><br><span class="line">            <span class="keyword">if</span>(ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Oops!!,Not equals, ans1 = &quot;</span> + ans1 + <span class="string">&quot;, ans2 = &quot;</span> + ans2);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Testcase: &quot;</span> + testTimes + <span class="string">&quot; pass!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Done successfully!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 归并排序相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2022/10/24/MergeSort/"/>
      <url>/2022/10/24/MergeSort/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-归并排序算法思想"><a href="#1-归并排序算法思想" class="headerlink" title="1. 归并排序算法思想"></a>1. 归并排序算法思想</h1><p>归并排序使用的是分治的思想，把问题拆分成子问题，逐个解决子问题，在把子问题的解合并，得到原问题的解。</p><h1 id="2-递归的归并排序"><a href="#2-递归的归并排序" class="headerlink" title="2. 递归的归并排序"></a>2. 递归的归并排序</h1><h2 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1. 算法描述"></a>2.1. 算法描述</h2><p>对于一个数组array，数组的长度是size：</p><ol><li>如果size&#x3D;&#x3D;1，那么数组已经有序了，返回；否则进行下面的步骤，</li><li>把原数组拆分成长度近似相等的两个子数组（如果size是奇数，那么无法平均分配），递归调用归并排序的方法，对这两个子数组进行排序；</li><li>把排好序的两个子数组和并在一起。</li></ol><h2 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2. 代码"></a>2.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortRecursively</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        sort(array,<span class="number">0</span>,array.length - <span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">int</span>[array.length]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> r,<span class="type">int</span>[] help)</span> &#123;</span><br><span class="line">        <span class="comment">// 对数组的[l..r]部分进行排序，使用辅助数组help</span></span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">// 获取中点位置，使用&gt;&gt;&gt;是为了防止溢出</span></span><br><span class="line">        sort(array,l,m,help);</span><br><span class="line">        sort(array,m + <span class="number">1</span>,r,help);</span><br><span class="line">        merge(array,l,m,r,help);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> m ,<span class="type">int</span> r, <span class="type">int</span>[] help)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r) help[k++] = array[i] &lt;= array[j] ? array[i++] : array[j++];<span class="comment">// 谁小拷贝谁，相等的时候，优先考虑左组（保证排序算法的稳定性）</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m) help[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) help[k++] = array[j++];</span><br><span class="line">        System.arraycopy(help,<span class="number">0</span>,array,l,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，空间复杂度$O(N)$的合并辅助空间以及$O(\log_2N)$的递归栈空间。</p><h1 id="3-迭代的归并排序"><a href="#3-迭代的归并排序" class="headerlink" title="3. 迭代的归并排序"></a>3. 迭代的归并排序</h1><p>递归版本的是从上往下的方法，大数组不断拆分成小数组。迭代的方法是从下往上的方法，先考虑合并最小的分组，然后逐渐增加分组的长度，直到整个数组变成一个分组的时候，数组就排好序了。</p><h2 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1. 算法描述"></a>3.1. 算法描述</h2><p>数组待排序部分的长度记为len，分组长度groupLen初始化为1；数组待排序部分开始下标l，末尾下标r；</p><p>只要groupLen&lt;len，就执行下面的步骤：</p><ol><li>使用一个变量x表示当前分组的开始位置，x初始化为l；只要x&lt;r，执行下面的步骤；<ol><li>如果数组剩余部分刚好够左分组的长度，或者不够左分组的长度，那么此时是没有右分组的，因此直接退出内循环；</li><li>否则，有右分组，那么确定右分组的结束位置y，以及左分组的结束位置mid；</li><li>执行merge操作</li><li>开始位置x &#x3D; y+1；</li></ol></li><li>如果分组长度groupLen已经超过了数组的长度了，那么退出外循环，排序结束，</li><li>否则groupLen *&#x3D; 2</li></ol><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortIteratively</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        sort(array,<span class="number">0</span>,array.length - <span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">int</span>[array.length]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[] help)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> r - l + <span class="number">1</span>, groupLen = <span class="number">1</span>, x, m, y;</span><br><span class="line">        <span class="keyword">while</span>(groupLen &lt; len) &#123;</span><br><span class="line">            x = l;</span><br><span class="line">            <span class="keyword">while</span>(x &lt; r) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>((m = x + groupLen - <span class="number">1</span>) &gt;= r) <span class="keyword">break</span>;<span class="comment">// m是左组的结束位置，如果m不小于r，则说明此时没有右组了，因此结束</span></span><br><span class="line">                y = Math.min(m + groupLen, r);<span class="comment">// 有右组，但是右组不一定是满的，因此右组的结束位置是r和m+groupLen的二者的最小值。</span></span><br><span class="line">                merge(array,x,m,y,help);</span><br><span class="line">                x = y + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(groupLen &gt; (len &gt;&gt; <span class="number">1</span>)) <span class="keyword">break</span>; <span class="comment">// 这里不能使用 if((groupLen &lt;&lt; 1) &gt; len)，因为groupLen 乘以2以后可能会溢出。</span></span><br><span class="line">            groupLen &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r, <span class="type">int</span>[] help)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m &amp;&amp; j &lt;= r) help[k++] = array[i] &lt;= array[j] ? array[i++] : array[j++];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= m) help[k++] = array[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r) help[k++] = array[j++];</span><br><span class="line">        System.arraycopy(help,<span class="number">0</span>,array,l,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$，空间复杂度$O(N)$。没有过多的系统堆栈空间。</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSortTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxArraySize = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">while</span>(testTimes-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxArraySize) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] array1 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array2 = <span class="keyword">new</span> <span class="title class_">int</span>[size], array3 = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) array1[i] = array2[i] = array3[i] = r.nextInt(<span class="number">5000</span>);</span><br><span class="line">            Arrays.sort(array1);</span><br><span class="line">            MergeSortRecursively.sort(array2);</span><br><span class="line">            MergeSortIteratively.sort(array3);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(array1[i] != array2[i] || array1[i] != array3[i]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Oops!!, Not equals&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;array:&quot;</span>);</span><br><span class="line">                    System.out.println(Arrays.toString(array1));</span><br><span class="line">                    System.out.println(<span class="string">&quot;array2:&quot;</span>);</span><br><span class="line">                    System.out.println(Arrays.toString(array2));</span><br><span class="line">                    System.out.println(<span class="string">&quot;array3:&quot;</span>);</span><br><span class="line">                    System.out.println(Arrays.toString(array3));</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Test case: &quot;</span> + testTimes + <span class="string">&quot; pass&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Done Successfully!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
          <category> 归并排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分解质因数</title>
      <link href="/2022/10/24/PrimeNumberDecomposition/"/>
      <url>/2022/10/24/PrimeNumberDecomposition/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>编写一个程序，给定一个正整数n（n&gt;&#x3D;2），分解质因数，返回分解结果。</p><p>例如：</p><ol><li>n&#x3D;6，返回：[2,3]；</li><li>n&#x3D;18，返回[2,3,3]；</li><li>n&#x3D;3，返回[3]</li></ol><h1 id="2-算法描述"><a href="#2-算法描述" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h1><p>准备一个答案列表ans，设置一个循环遍历i从2开始，循环条件是i&lt;&#x3D;n；对于每一个i：</p><ol><li>如果i&#x3D;&#x3D;n，那么把i加入ans，返回；</li><li>只要n%i&#x3D;&#x3D;0，那么就把i加入ans；n&#x2F;&#x3D;i;</li><li>如果n是质数，那么就把n加入ans，返回，否则i++</li></ol><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimeNumberDecomposition</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">decomposition</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == n) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">                n /= i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(primeNum(n)) &#123;</span><br><span class="line">                ans.add(n);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">primeNum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n != <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">6</span> != <span class="number">1</span> &amp;&amp; n % <span class="number">6</span> != <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>, limit = (<span class="type">int</span>)Math.sqrt(n); i &lt;= limit; i += <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span> || n % (i + <span class="number">2</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;Input your number please:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Result is: &quot;</span> + decomposition(num));</span><br><span class="line">            System.out.println(<span class="string">&quot;Input your number please:&quot;</span>);</span><br><span class="line">            num = sc.nextInt();</span><br><span class="line">        &#125;<span class="keyword">while</span>(num != <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Bye~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 数学相关 </category>
          
          <category> 素数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>筛选素数</title>
      <link href="/2022/10/20/getPrimeNums/"/>
      <url>/2022/10/20/getPrimeNums/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>给定一个正整数n，返回$[1,n]$之间的所有素数。结果按照从小到大的顺序排列。</p><p>相关测评：<a href="https://leetcode-cn.com/problems/count-primes/">https://leetcode-cn.com/problems/count-primes/</a></p><h1 id="2-暴力解法"><a href="#2-暴力解法" class="headerlink" title="2. 暴力解法"></a>2. 暴力解法</h1><h2 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1. 算法描述"></a>2.1. 算法描述</h2><p>遍历$[1,n]$之间的所有数字，对于每一个判断其是不是素数，是的话就加入列表。</p><h2 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2. 代码"></a>2.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPrimeNums</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getPrimeNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(i)) ans.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, limit = (<span class="type">int</span>)Math.sqrt(n); i &lt;= limit; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\sqrt{N})$，额外空间复杂度$O(1)$。</p><h1 id="3-埃氏筛"><a href="#3-埃氏筛" class="headerlink" title="3. 埃氏筛"></a>3. 埃氏筛</h1><h2 id="3-1-算法分析"><a href="#3-1-算法分析" class="headerlink" title="3.1. 算法分析"></a>3.1. 算法分析</h2><p>任何一合数都可以表示成几个素数的乘积，即一个合数一定是素数的倍数，因此我们只需要把素数的倍数筛掉，剩下的都是素数了。</p><p>因此我们需要一个标记数组prime来表示哪些数字是素数，初始化全部为true，表示都是素数。</p><p>i从2开始到n，遍历数组</p><ol><li>如果当前位置是true，那么从$2i$开始，步长是$i$，到$n$，把这些数字设置为false。</li><li>如果当前位置是false，表示当前位置已经是一个合数了，因此跳过。</li><li>最后遍历一次数组（从2开始），收集为true的数即可。</li></ol><blockquote><p>证明：</p><ol><li>当i&gt;2的时候，如果此时prime[i]是true，那么说明$[2,i-1]$之间的所有素数的倍数，都不是i，这是因为如果i是$[2,i-1]$之间某个素数x的倍数的话，那么当我们在遍历x的时候，i一定会被设置为false。因此如果prime[i]是true，那么就代表它不能被$[2,i-1]$之间的任何一个素数整除，那么i就是素数。</li><li>当i&#x3D;&#x3D;2的时候，2本身是素数</li></ol><p>因此上面的方法是正确的。</p></blockquote><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPrimeNumsEratosthenes</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getPrimeNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">boolean</span>[] prime = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(visit,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i &lt;&lt; <span class="number">1</span>; j &lt;= n; j += i) visit[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[i]) ans.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编码技巧：</p><ol><li>可以设置一个notPrime数组，即非素数数组，标记为true的都是非素数，由于java语言的特性，数组初始化的时候全部都是false，因此就省掉了第9行的代码，减少常数时间。</li><li>最后不用再次遍历一遍数组收集答案，可以在第一次遍历的时候，一边遍历，一边收集答案，代码更精简。</li></ol></blockquote><blockquote><p>算法优化点：</p><ol><li>第12行代码的j不需要从$2i$开始，可以从$i<em>i$开始，这是因为，当我们要把$x</em>i(x&lt;i)$设置为false的时候，其实在我们遍历x的时候，$x*i$已经设置过了，因此不需要重复设置。</li></ol></blockquote><p>于是优化后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPrimeNumsEratosthenes</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getPrimeNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">boolean</span>[] notPrime = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!notPrime[i]) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">long</span>)i * i; j &lt;= n; j += i) notPrime[(<span class="type">int</span>)j] = <span class="literal">true</span>;<span class="comment">// 用long类型防止因为i太大导致溢出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度$O(N)$，时间复杂度$O(N\log_2(\log_2N))$，时间复杂度证明参考：<a href="https://www.cnblogs.com/alfayoung/p/16154640.html">https://www.cnblogs.com/alfayoung/p/16154640.html</a></p><h1 id="4-欧拉筛"><a href="#4-欧拉筛" class="headerlink" title="4. 欧拉筛"></a>4. 欧拉筛</h1><h2 id="4-1-算法分析"><a href="#4-1-算法分析" class="headerlink" title="4.1. 算法分析"></a>4.1. 算法分析</h2><p>埃氏筛是遇到一个素数，就筛掉这个素数的倍数，但是这样会存在重复筛掉一个数的情况，例如当遇到素数2的时候，筛掉2的6倍，即$2<em>6&#x3D;12$，当我们们遇到3的时候，会筛掉3的4倍，即$3</em>4&#x3D;12$，但是12在遇到2的时候已经被筛掉了，这是一个重复操作。</p><p>实际上，假设一个合数X有N个不同的素约数，那么他就会被筛掉N次，那么如何才能避免这样的重复操作呢？</p><p>我们先说明欧拉筛的算法，然后再说明欧拉筛是如何避免重复筛选的。</p><p>准备一个标记数组isPrime，长度是n+1，和一个素数列表primeList，刚开始标记数组都初始化为true，认为从$[2,n]$都是素数；</p><ol><li><p>对$[2,n]$中的每一个数字x，如果isPrime[x]是true，即x是素数，那么把这个数加入primeList；</p></li><li><p>遍历已经得到的primeList，对于其中的任何一个数字p；</p><ul><li>如果$p<em>x &gt; n$，退出遍历；否则设置isPrime[$p</em>x$] &#x3D; false;</li><li>如果x能被p整除，那么退出遍历；</li></ul></li></ol><p>最后primeList中的数就是结果；</p><blockquote><p>证明：</p><ol><li>对于任何一个合数X，都可以分解成$X &#x3D; p_{xmin} * B$，其中$p_{xmin}$是$X$的最小素约数，也正是因为是最小素约数，所以B的最小素约数$p_{bmin}$，不会超过$p_{xmin}$（这是因为B是X的一个约数，如果B的最小素约数比$p_{xmin}$还小，那么$p_{xmin}$就不是X的最小素约数了，因此和假设矛盾），而且显然的，B&lt;X，$p_{xmin}&lt;&#x3D;B$，因此B比X先被外层循环遍历到，$p_{xmin}$比B先被遍历到，当遍历到B的时候，$p_{xmin}$已经被处理过了，因此在遍历到B进入内层循环的时候，$p_{xmin}$已经在素数列表中了，又因为B的最小素约数不小于$p_{xmin}$，因此在内循环中，遍历到素数$p_{bmin}$的时候。一定可以遍历到$p_{xmin}$，因此isPrime[X]一定会被设置为false；因此这个方法可以保证任何一个合数都能被筛掉；</li><li>那么合数X没有可能被X的其他素约数筛掉呢？不可能。假设X还有另一个素约数$p_{xother}$，那么就有$X&#x3D;p_{xmin}*B&#x3D;p_{xother}*C$成立，即$C&#x3D;p_{xmin}*\frac{B}{p_{xother}}$成立，因为C是个整数，因此$\frac{B}{p_{xother}}$也是整数，此时$p_{xmin}$就是$C$的素约数；因此当最外层循环遍历到$C$的时候，内层循环是从小到大遍历已经得到的素数表的，因此一定会先遇到$p_{xmin}$，而此时$p_{xmin}$是$C$的素约数，因此内层循环直接退出，B没有机会和$p_{xother}$结合再次筛掉X。</li></ol><p>因此一个合数X一定且只会被他的最小素约数筛掉，如果他没有被之前的素数筛掉，那么X就是一个素数。</p><p>证明参考：<a href="https://blog.csdn.net/qaqwqaqwq/article/details/123587336">https://blog.csdn.net/qaqwqaqwq/article/details/123587336</a></p></blockquote><h2 id="4-2-代码"><a href="#4-2-代码" class="headerlink" title="4.2. 代码"></a>4.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPrimeNumsEuler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">getPrimeNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">boolean</span>[] notPrime = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!notPrime[i]) ans.add(i);<span class="comment">// 如果i是素数，就加入素数列表</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, limit = ans.size(); j &lt; limit &amp;&amp; (<span class="type">long</span>)i * ans.get(j) &lt;= n; ++j) &#123;</span><br><span class="line">                notPrime[i * ans.get(j)] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(i % ans.get(j) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一因为一个合数最多只会被筛掉1次，n个数中合数的个数不会超过n，因此12行代码执行最多不会超过n次，因此时间复杂度$O(N)$，空间复杂度$O(N)$。</p><h1 id="5-测试程序"><a href="#5-测试程序" class="headerlink" title="5. 测试程序"></a>5. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPrimeNumsTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100_0000</span>; ++i) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            List&lt;Integer&gt; ans = GetPrimeNums.getPrimeNums(i);</span><br><span class="line">            <span class="type">long</span> <span class="variable">ansTimeCost</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">            start = System.currentTimeMillis();</span><br><span class="line">            List&lt;Integer&gt; ans2 = GetPrimeNumsEratosthenes.getPrimeNums(i);</span><br><span class="line">            <span class="type">long</span> <span class="variable">ans2TimeCost</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">            start = System.currentTimeMillis();</span><br><span class="line">            List&lt;Integer&gt; ans3 = GetPrimeNumsEuler.getPrimeNums(i);</span><br><span class="line">            <span class="type">long</span> <span class="variable">ans3TimeCost</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">            System.out.println(<span class="string">&quot;i is: &quot;</span> + i + <span class="string">&quot;, GetPrimeNums method time cost: &quot;</span> + ansTimeCost + <span class="string">&quot;ms, GetPrimeNumsEratosthenes method time cost: &quot;</span> + ans2TimeCost + <span class="string">&quot;ms, GetPrimeNumsEuler method time cost： &quot;</span> + ans3TimeCost + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(ans.size() != ans2.size() || ans.size() != ans3.size()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;answer size is not equal! ans size is: &quot;</span> + ans.size() + <span class="string">&quot;, ans2 size is: &quot;</span> + ans2.size() + <span class="string">&quot;ans3 size is: &quot;</span> + ans3.size() + <span class="string">&quot;, i is: &quot;</span> + i);</span><br><span class="line">                System.out.println(<span class="string">&quot;Oops!!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, limit = ans.size(); j &lt; limit; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!ans.get(j).equals(ans2.get(j)) || !ans.get(j).equals(ans3.get(j))) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Not equals!, j is: &quot;</span> + j + <span class="string">&quot;, ans[&quot;</span> + j + <span class="string">&quot;] is: &quot;</span> + ans.get(j) + <span class="string">&quot;, ans2[&quot;</span> + j + <span class="string">&quot;] is: &quot;</span> + ans2.get(j) + <span class="string">&quot;, ans3[&quot;</span> + j + <span class="string">&quot;] is: &quot;</span> + ans3.get(j));</span><br><span class="line">                    System.out.println(<span class="string">&quot;Oops!!&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Done successfully !!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-相关阅读"><a href="#6-相关阅读" class="headerlink" title="6. 相关阅读"></a>6. 相关阅读</h1><p><a href="https://blog.csdn.net/m0_54123999/article/details/126103903">https://blog.csdn.net/m0_54123999/article/details/126103903</a></p><p><a href="https://zhuanlan.zhihu.com/p/385530517">https://zhuanlan.zhihu.com/p/385530517</a></p><p><a href="https://blog.csdn.net/Gavin_Nicholas/article/details/88974079">https://blog.csdn.net/Gavin_Nicholas/article/details/88974079</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 数学相关 </category>
          
          <category> 素数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数判断</title>
      <link href="/2022/10/20/judgePrimeNum/"/>
      <url>/2022/10/20/judgePrimeNum/</url>
      
        <content type="html"><![CDATA[<!-- toc --><p>给定一个正整数n，判断它是不是素数。</p><h1 id="1-算法分析"><a href="#1-算法分析" class="headerlink" title="1. 算法分析"></a>1. 算法分析</h1><ol><li><p>如果n是1，返回false；</p></li><li><p>否则，从2到$\lfloor\sqrt{n}\rfloor$，逐个尝试，如果能被整除，那么返回false</p><blockquote><p>按照定义我们是要枚举$[2,n-1]$之间的所有的数字，如果都没有找到一个可以证除n的数，那么n是素数。</p><p>因为一个数的约数a，b是成对存在的，且一定有一个不超过$\lfloor\sqrt{n}\rfloor$，有一个不小于$\lfloor\sqrt{n}\rfloor$，那么我们只需要在$[2,\lfloor\sqrt{n}\rfloor]$这个区间寻找就可以了，如果没有发现一个可以整除n的数，那么n就是素数。</p></blockquote></li><li><p>返回true</p></li></ol><h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgePrimeNum</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, limit = (<span class="type">int</span>)Math.sqrt(n); i &lt;= limit; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(isPrime(<span class="number">1</span>));<span class="comment">// false</span></span><br><span class="line">        System.out.println(isPrime(<span class="number">2</span>));<span class="comment">// true</span></span><br><span class="line">        System.out.println(isPrime(<span class="number">3</span>));<span class="comment">// true</span></span><br><span class="line">        System.out.println(isPrime(<span class="number">4</span>));<span class="comment">// false</span></span><br><span class="line">        System.out.println(isPrime(<span class="number">7</span>));<span class="comment">// true</span></span><br><span class="line">        System.out.println(isPrime(<span class="number">91</span>));<span class="comment">// false 13 * 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(\sqrt{N})$</p><h1 id="3-进一步优化"><a href="#3-进一步优化" class="headerlink" title="3. 进一步优化"></a>3. 进一步优化</h1><p>可以先怕判断一下n是不是偶数，否则，我们可以只枚举奇数因子，降低常数时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgePrimeNum2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 排除偶数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>, limit = (<span class="type">int</span>)Math.sqrt(n); i &lt;= limit; i += <span class="number">2</span>) &#123;<span class="comment">// 只枚举奇数因子</span></span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-再次优化"><a href="#4-再次优化" class="headerlink" title="4. 再次优化"></a>4. 再次优化</h1><p>有一个性质，大于3的素数，一定可以写成$6k-1$和$6k+1$的形式（k&gt;&#x3D;1），即大于3的素数，都和6的倍数紧邻。且这样的素数的约数，只有可能是$6k-1$和$6k+1$的形式。</p><blockquote><p>这是因为$6k+2$，$6k+3$，$6k+4$都是合数，只有$6k+1$，$6k+5 &#x3D; 6k-1$有可能是素数。因此如果一个数是素数，那么一定是写成$6k-1$和$6k+1$的形式（k&gt;&#x3D;1）。</p><p>除了2的素数，都是奇数，因此大于3的素数，他们也只能是奇数，因此他们不可能被形如$6k+2$，$6k+4$这样的数整除，因为$6k+2$，$6k+4$都是偶数。</p><p>那么$6k+1$能否被$6k+3$整除呢？不可能，这是因为，如果$6k+1$能被$6k+3$整除的话，那么一定有$6k+1 &#x3D; p(6m+3)$p是正整数成立，即$6k+1 &#x3D; 3p(2m+1)$成立，那么$6k+1$可以被3整除。但实际上很显然，$6k+1$是不可能被3整除的，$6k-1$也是如此。</p><p>那么能整除大于3的素数的，只有可能是$6k-1$和$6k+1$的形式的数了。</p><p>参考文章：<a href="https://blog.csdn.net/weixin_41423494/article/details/84200612">https://blog.csdn.net/weixin_41423494/article/details/84200612</a></p></blockquote><p>所以对于素数2和3我们只需特殊判断一下，对于大于3的素数，我们只需枚举其形如$6k-1$和$6k+1$的约数即可，如果只要有一个可以整除，那么不是素数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgePrimeNum3</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n != <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">6</span> != <span class="number">1</span> &amp;&amp; n % <span class="number">6</span> != <span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>, limit = (<span class="type">int</span>)Math.sqrt(n); i &lt;= limit; i += <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span> || n % (i + <span class="number">2</span>) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-测试程序"><a href="#5-测试程序" class="headerlink" title="5. 测试程序"></a>5. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgePrimeNumTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">100_0000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; ++i) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> JudgePrimeNum.isPrime(i);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ans2</span> <span class="operator">=</span> JudgePrimeNum2.isPrime(i);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ans3</span> <span class="operator">=</span> JudgePrimeNum3.isPrime(i);</span><br><span class="line">            <span class="keyword">if</span>((ans ^ ans2) || (ans ^ ans3)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Oops! i is: &quot;</span> + i + <span class="string">&quot;, ans :&quot;</span> + ans + <span class="string">&quot;, ans2: &quot;</span> + ans2 + <span class="string">&quot;, ans3: &quot;</span> + ans3);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Done successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 数学相关 </category>
          
          <category> 素数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出现最频繁的K个单词</title>
      <link href="/2022/10/19/TopKFrequentWords/"/>
      <url>/2022/10/19/TopKFrequentWords/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>给定一个单词流，单词个数未知的。现在需要设计一种结构，它可以接收一个单词，也可以返回到目前为止，出现次数最多的K个单词。用户会在某些时候要求查询出现次数最多的K个单词，按照出现次数升序，字典序降序的顺序输出。</p><p>K通过构造方法传入，K&gt;0</p><p>测评链接：<a href="https://www.lintcode.com/problem/550/">https://www.lintcode.com/problem/550/</a></p><h1 id="2-暴力解法"><a href="#2-暴力解法" class="headerlink" title="2. 暴力解法"></a>2. 暴力解法</h1><h2 id="2-1-算法分析"><a href="#2-1-算法分析" class="headerlink" title="2.1. 算法分析"></a>2.1. 算法分析</h2><ol><li>使用list存储每一个单词及其出现次数</li><li>使用哈希表存储每一个单词内容和单词本身的映射。</li><li>对于每次添加的操作，先在哈希表中查找是否存在单词，如果存在则获取其引用，增加其出现从次数，如果不存在，则新建一个单词的引用，出现次数是1，添加到list和哈希表。</li><li>对于每次获取topk操作，先对list按照出现次数从大到小，字典序从大到小排序，取前K个单词即可。</li></ol><h2 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2. 代码"></a>2.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KFrequentWords</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;WordInfo&gt; data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String,WordInfo&gt; wordMap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;WordInfo&gt; cmp = (a,b) -&gt; a.cnt != b.cnt ? b.cnt - a.cnt : b.word.compareTo(a.word); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KFrequentWords</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        wordMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">WordInfo</span> <span class="variable">wi</span> <span class="operator">=</span> wordMap.get(word);</span><br><span class="line">        <span class="keyword">if</span>(wi == <span class="literal">null</span>) &#123;</span><br><span class="line">            wi = <span class="keyword">new</span> <span class="title class_">WordInfo</span>(word);</span><br><span class="line">            wordMap.put(word,wi);</span><br><span class="line">            data.add(wi);</span><br><span class="line">        &#125;<span class="keyword">else</span> ++wi.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getTopKWords</span><span class="params">()</span> &#123;</span><br><span class="line">        data.sort(cmp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(k,data.size()) - <span class="number">1</span>;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(end + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= end; ++i)</span><br><span class="line">            ans.add(data.get(i).word);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WordInfo</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String word;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WordInfo</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">this</span>.word = word;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">KFrequentWords</span> <span class="variable">kfw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KFrequentWords</span>(<span class="number">3</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        System.out.println(kfw.getTopKWords());<span class="comment">// yes,hello,C++</span></span><br><span class="line">        kfw.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        System.out.println(kfw.getTopKWords());<span class="comment">// yes,hello,C++</span></span><br><span class="line">        kfw.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        System.out.println(kfw.getTopKWords());<span class="comment">// yes,C++,hello</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><h2 id="3-1-算法分析"><a href="#3-1-算法分析" class="headerlink" title="3.1. 算法分析"></a>3.1. 算法分析</h2><ol><li><p>还是使用哈希表存储每一个单词内容和其本身的映射；</p></li><li><p>使用一个长度为K的小根堆结构，维护出现次数最多且字典序最大的K个单词；还需要一个哈希表，告诉一个元素是否在堆上；</p></li><li><p>当新来一个单词的时候，如果不在map中那么新建出来，加入map，否则当前单词的出现次数++；</p><ul><li>如果当前单词在堆上，那么调整堆（此时只需要heapify，因为出现次数增加，又是小根堆）</li><li>如果当前单词不在堆上，<ul><li>如果堆size没有达到K，那么加入堆中，调整堆（heapInsert），</li><li>如果堆size达到K，然后看看它能否替换堆顶，如果可以则替换堆顶，调整堆</li></ul></li></ul></li><li><p>当需要获取topK的时候，只需要取出堆中的所有元素，排序即可。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KFrequentWords2</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WordInfo[] heap, help;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String,WordInfo&gt; wordMap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;WordInfo,Integer&gt; indexMap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;WordInfo&gt; heapCmp = (a,b) -&gt; a.cnt != b.cnt ? a.cnt - b.cnt : a.word.compareTo(b.word);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;WordInfo&gt; sortCmp = (a,b) -&gt; a.cnt != b.cnt ? b.cnt - a.cnt : b.word.compareTo(a.word);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">KFrequentWords2</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="title class_">WordInfo</span>[k];</span><br><span class="line">        help = <span class="keyword">new</span> <span class="title class_">WordInfo</span>[k];</span><br><span class="line">        wordMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">WordInfo</span> <span class="variable">wi</span> <span class="operator">=</span> wordMap.get(word);</span><br><span class="line">        <span class="keyword">if</span>(wi == <span class="literal">null</span>) &#123;<span class="comment">// 不在Map则新建</span></span><br><span class="line">            wi = <span class="keyword">new</span> <span class="title class_">WordInfo</span>(word);</span><br><span class="line">            wordMap.put(word,wi);</span><br><span class="line">        &#125;<span class="keyword">else</span> ++wi.cnt;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> indexMap.get(wi);</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="literal">null</span>) &#123;<span class="comment">// 不在堆上</span></span><br><span class="line">            <span class="keyword">if</span>(size &lt; k) &#123;<span class="comment">// 堆不满，则放入堆中</span></span><br><span class="line">                heap[size] = wi;</span><br><span class="line">                indexMap.put(wi,size);</span><br><span class="line">                heapInsert(size++);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">// 堆满，则看看能否替换堆顶</span></span><br><span class="line">                <span class="keyword">if</span>(heapCmp.compare(heap[<span class="number">0</span>],wi) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    indexMap.put(wi,<span class="number">0</span>);</span><br><span class="line">                    indexMap.remove(heap[<span class="number">0</span>]);</span><br><span class="line">                    heap[<span class="number">0</span>] = wi;</span><br><span class="line">                    heapIfy(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> heapIfy(index); <span class="comment">// 在堆上，则调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getTopKWords</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.min(k,size);</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) help[i] = heap[i];</span><br><span class="line">        Arrays.sort(help,<span class="number">0</span>,len,sortCmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) ans.add(help[i].word);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> parent;</span><br><span class="line">        <span class="keyword">while</span>(heapCmp.compare(heap[index],heap[parent = (index - <span class="number">1</span>) / <span class="number">2</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(index,parent);</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapIfy</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> child, bnd = size &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; bnd) &#123;</span><br><span class="line">            child = (index &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(child + <span class="number">1</span> &lt; size &amp;&amp; heapCmp.compare(heap[child],heap[child+<span class="number">1</span>]) &gt; <span class="number">0</span>) ++child;</span><br><span class="line">            <span class="keyword">if</span>(heapCmp.compare(heap[index],heap[child]) &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            swap(index,child);</span><br><span class="line">            index = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">              </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">WordInfo</span> <span class="variable">wi</span> <span class="operator">=</span> heap[i], wj = heap[j];</span><br><span class="line">        indexMap.put(wi,j);</span><br><span class="line">        indexMap.put(wj,i);</span><br><span class="line">        heap[i] = wj;</span><br><span class="line">        heap[j] = wi;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WordInfo</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> String word;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WordInfo</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.word = word;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">              </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">KFrequentWords2</span> <span class="variable">kfw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KFrequentWords2</span>(<span class="number">3</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        System.out.println(kfw.getTopKWords());<span class="comment">// yes,hello,C++</span></span><br><span class="line">        kfw.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">        System.out.println(kfw.getTopKWords());<span class="comment">// yes,hello,C++</span></span><br><span class="line">        kfw.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        kfw.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        System.out.println(kfw.getTopKWords());<span class="comment">// yes,C++,hello</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KFrequentWordsTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxWordCnt = <span class="number">20</span>,maxK = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>(testTimes-- &gt; <span class="number">0</span>) &#123;<span class="comment">// 测试testTimes次</span></span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt(maxK) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> r.nextInt(maxWordCnt) + <span class="number">1</span>;</span><br><span class="line">            String[] words = <span class="keyword">new</span> <span class="title class_">String</span>[wc];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wc; ++i) words[i] = getWord(r);<span class="comment">// 生成wc个单词</span></span><br><span class="line">            <span class="type">KFrequentWords2</span> <span class="variable">kfw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KFrequentWords2</span>(k);</span><br><span class="line">            <span class="type">KFrequentWords</span> <span class="variable">kfw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KFrequentWords</span>(k);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wc; ++i) &#123;</span><br><span class="line">                kfw2.add(words[i]);</span><br><span class="line">                kfw.add(words[i]);</span><br><span class="line">                <span class="keyword">if</span>(r.nextInt(<span class="number">2</span>) == <span class="number">0</span>) &#123;<span class="comment">// 一半的概率获取topK</span></span><br><span class="line">                    List&lt;String&gt; ans2 = kfw2.getTopKWords(), ans =  kfw.getTopKWords();</span><br><span class="line">                    <span class="keyword">if</span>(ans2.size() != ans.size()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Oops!! ans2.size:&quot;</span> + ans2.size() + <span class="string">&quot; ans.size:&quot;</span> + ans.size());</span><br><span class="line">                        System.out.println(<span class="string">&quot;All words:&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; wc; ++j) &#123;</span><br><span class="line">                            System.out.print(words[j]);</span><br><span class="line">                            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        System.out.println(<span class="string">&quot;ans2:&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ans2.size(); ++j) &#123;</span><br><span class="line">                            System.out.print(ans2.get(j));</span><br><span class="line">                            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        System.out.println(<span class="string">&quot;ans:&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ans.size(); ++j) &#123;</span><br><span class="line">                            System.out.print(ans.get(j));</span><br><span class="line">                            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">ansSize</span> <span class="operator">=</span> ans.size();</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">kk</span> <span class="operator">=</span> <span class="number">0</span>; kk &lt; ansSize; ++kk) &#123;</span><br><span class="line">                            <span class="keyword">if</span>(!ans.get(kk).equals(ans2.get(kk))) &#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;Oops!! Not equals at:&quot;</span> + kk + <span class="string">&quot;ans[&quot;</span> + kk +<span class="string">&quot;]:&quot;</span> + ans.get(kk) + <span class="string">&quot;, ans2[&quot;</span> + kk + <span class="string">&quot;]:&quot;</span> + ans2.get(kk));</span><br><span class="line">                                </span><br><span class="line">                                System.out.println(<span class="string">&quot;All words:&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; wc; ++j) &#123;</span><br><span class="line">                            System.out.print(words[j]);</span><br><span class="line">                            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        System.out.println(<span class="string">&quot;ans2:&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ans2.size(); ++j) &#123;</span><br><span class="line">                            System.out.print(ans2.get(j));</span><br><span class="line">                            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        System.out.println(<span class="string">&quot;ans:&quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ans.size(); ++j) &#123;</span><br><span class="line">                            System.out.print(ans.get(j));</span><br><span class="line">                            System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Done successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getWord</span><span class="params">(Random r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> r.nextInt(<span class="number">20</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) sb.append((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+r.nextInt(<span class="number">26</span>)));</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 堆相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大线段重合问题</title>
      <link href="/2022/10/16/MaxLineCoincide/"/>
      <url>/2022/10/16/MaxLineCoincide/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>给定一些整数对（a，b）代表数轴上的两个点，且a&lt;&#x3D;b，这两个点表示一个线段。请返回最多几个线段重叠在一起。</p><p>例如：</p><ol><li>[[1,3],[2,5],[7,9]]，因为[1,3]和[2,5]重叠在一起，返回2；</li><li>[[1,2],[2,3]]，返回2；</li><li>[[1,2],[2,3],[1,3]]，返回3</li><li>[[1,2]]，返回1</li></ol><p>数组长度至少是1，不超过100_0000；</p><h1 id="2-暴力解法"><a href="#2-暴力解法" class="headerlink" title="2. 暴力解法"></a>2. 暴力解法</h1><h2 id="2-1-算法分析"><a href="#2-1-算法分析" class="headerlink" title="2.1. 算法分析"></a>2.1. 算法分析</h2><p>我们可以用笔画几条线段发现，任何重叠的部分的左端点，都是某一个线段的左端点。比如[1,3]，和[2,4]重叠的部分是[2,3]，其中2就是第二个线段的左端点；又比如：[1,5]，[3,7]，[4,6]，重叠的部分是[4,5]，其中4就是[4,6]的左端点。既然任何一个重叠的部分都满足这个性质，那么重叠线段最多的那一部分，也满足。</p><p>因此我们只需要看一下，哪个左端点下经过的线段数目最多即可。</p><p>因此我们可以枚举所有线段的左端点，对于每一个左端点，再次枚举有几条线段经过当前点，返回最大值。</p><p>线段[a,b]经过当前点x的充要条件是：a&lt;&#x3D;x&lt;&#x3D;b</p><h2 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2. 代码"></a>2.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxLineCoincide</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxLineCoincide</span><span class="params">(<span class="type">int</span>[][] lines)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lines.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>, t, leftPoint;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            t=<span class="number">0</span>;</span><br><span class="line">            leftPoint = lines[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;len; ++j) &#123; </span><br><span class="line">                <span class="keyword">if</span>(lines[j][<span class="number">0</span>] &lt;= leftPoint &amp;&amp; leftPoint &lt;= lines[j][<span class="number">1</span>]) ++t;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(t,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] lines = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(maxLineCoincide(lines));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N^2)$</p><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><h2 id="3-1-算法分析"><a href="#3-1-算法分析" class="headerlink" title="3.1. 算法分析"></a>3.1. 算法分析</h2><p>上述的解答中，最耗时的部分在于对于每一个左端点，找有几条线段通过这个点？因为给定的线段列表是杂乱的，因此我们只能遍历去找，浪费了时间。</p><p>如果我们把所有的线段，按照左端点从小到大排序，那么我们在确定一个左端点有几条线段通过它的时候，就可以排除一些不必要的遍历。</p><p><strong><font color=red>即对于一个左端点leftx，能通过它的线段，只可能是左端点不超过leftx的线段，如果一个线段的左端点都超过了leftx，那么这个线段是不会通过leftx的。</font></strong></p><p>左端点不超过leftx的线段中，不都是满足条件的，只有那些右端点不小于leftx的线段，才是通过leftx的。因此我们还要知道这些线段的所有右端点信息，我们可以把这些线段的右端点都放在小跟堆中，不断从堆顶弹出一个右端点rightx，如果发现一个线段的右端点rightx，小于leftx，那么这个线段是不会计入leftx的答案的，当然在计算leftx的下一个（如果有的话）左端点nextLeftx的时候，更不会计入nextLeftx的答案，因此这个右端点rightx就丢弃了，直到某一个rightx不小于leftx的时候，因为是小跟堆，堆中所有的元素都是不小于leftx的，此时堆的size就是当前leftx的答案。</p><p>因此整体的算法如下：</p><ol><li>把所有的线段，按照左端点从小到大排序</li><li>设置一个小跟堆，遍历每一个线段，对于每一个线段line：<ul><li>把line的右端点rightx放入小跟堆；</li><li>只要堆顶元素小于当前线段的左端点leftx，则弹出</li><li>把堆此时的size作为子问题的答案，和全局答案pk</li></ul></li></ol><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxLineCoincide2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxLineCoincide</span><span class="params">(<span class="type">int</span>[][] lines)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lines.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        Arrays.sort(lines,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            q.offer(lines[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; q.peek() &lt; lines[i][<span class="number">0</span>]) q.poll();</span><br><span class="line">            ans = Math.max(ans,q.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] lines = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(maxLineCoincide(lines));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N\log_2N)$</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxLineCoincideTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">100_0000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArraySize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPoint</span> <span class="operator">=</span> <span class="number">10_0000</span>;</span><br><span class="line">        <span class="keyword">while</span>(testTimes-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r.nextInt(maxArraySize) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[][] data = <span class="keyword">new</span> <span class="title class_">int</span>[size][<span class="number">2</span>], data2 = <span class="keyword">new</span> <span class="title class_">int</span>[size][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                data[i][<span class="number">0</span>] = r.nextInt(maxPoint);</span><br><span class="line">                <span class="comment">//保证data[i][1]不小于data[i][0]</span></span><br><span class="line">                data[i][<span class="number">1</span>] = data[i][<span class="number">0</span>] + r.nextInt(Integer.MAX_VALUE - data[i][<span class="number">0</span>]);</span><br><span class="line">                data2[i][<span class="number">0</span>] = data[i][<span class="number">0</span>];</span><br><span class="line">                data2[i][<span class="number">1</span>] = data[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans0</span> <span class="operator">=</span> MaxLineCoincide.maxLineCoincide(data);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> MaxLineCoincide2.maxLineCoincide(data2);</span><br><span class="line">            <span class="keyword">if</span>(ans0 != ans1) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ans0: &quot;</span> + ans0 + <span class="string">&quot; ans1: &quot;</span> + ans1);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                    System.out.println(Arrays.toString(data[i]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Oops&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Done successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 堆相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽奖系统问题</title>
      <link href="/2022/10/14/Lottery/"/>
      <url>/2022/10/14/Lottery/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h1><p>有一个抽奖系统，规则如下：</p><p>给定两个整数数组，ids代表用户ID列表，ops代表操作，二者等长。对于每一个位置i，如果ops[i]=&#x3D;0，代表ID为ids[i]的用户退了一件货物，ops[i]&#x3D;&#x3D;1代表他购买了一件货物。有两个区域，一个是获奖区域，一个是候选区域，最多k个人获奖。</p><p>如果一个用户购买了一件货物，此时：</p><ul><li>如果获奖区域人数没满，且他没进入过获奖区域的话，那么他直接进入获奖区域，以前进入过就不做任何操作。</li><li>如果获奖区域的人数满了，那么如果他以前没进入过候选区域，则直接进入候选区域，以前进入过候选区域就不做任何操作。</li></ul><p>此时如果发现候选区域的某个人X的购买数量大于获奖区域的某个人（或者某些人）的购买数量的话，则候选区域这个人进入获奖区域，原来获奖区域的人被替换，进入候选区域。如果原来获奖区域多个人的购买数量都小于X的购买数量的话，则替换掉最先进入获奖区域的那个用户。</p><p>如果一个用户退了一件货物，此时：</p><ul><li>如果他的购买数量已经是0了，抽奖系统不允许购买数量是负数，因此跳过这种情况</li><li>如果用户只有最后一件货物了，退了以后，用户的购买数量就是0了， 那么不管他原来在那个区域，都退出原来的区域；</li></ul><p>如果他退了一件货物以后，发现获奖区域Y某个人购买数量已经小于候选区域某个人（或者某些人）的购买数量的话，则Y退出获奖区域进入候选区域，候选区域的人进入获奖区域，如果候选区域有多个人的购买数量都大于Y的购买数量的话，那么最早进入候选区域的那个用户进入获奖区域。</p><p>总结来说就是，一个抽奖系统，在获奖区域还没满的时候，只要购买数量大于0的用户，都可以直接进入获奖区域；获奖区域满了的话，购买数量大于0的用户则进入候选区域，每一次购买或者退货事件发生的时候，凭着购买数量多，且先到先得的原则，去更新获奖区域。</p><p>现在给定这两个数组，编写代码计算每一次购买退货事件发生的时候，获奖区域的用户ID列表。</p><p>ops[i]只有0和1两个值</p><p>ids[i]可以是任意整数。</p><p>k&gt;0</p><h1 id="2-暴力做法"><a href="#2-暴力做法" class="headerlink" title="2. 暴力做法"></a>2. 暴力做法</h1><h2 id="2-1-算法分析"><a href="#2-1-算法分析" class="headerlink" title="2.1. 算法分析"></a>2.1. 算法分析</h2><ol><li>使用一个结构保存用户的id，购买数量和进入每个区域的时刻；</li><li>使用哈希表记录每一个id的用户；</li><li>使用list保存获奖区域和候选区域的用户</li><li>每次事件发生的时候，如果还没有更新获奖区域，且候选区域还有人的情况下，按照购买数量升序，到达时间降序对候选区域进行排序，按照按照购买数量降序，到达时间降序对获奖区域排序，用候选区域的最后一个替换获奖区域的最后一个即可。</li><li>收集答案</li></ol><h2 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2. 代码"></a>2.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LotteryGameMethod1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getLotteryUidList</span><span class="params">(<span class="type">int</span>[] ids, <span class="type">int</span>[] ops, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        HashMap&lt;Integer,User&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">// 这里保存的是购买数量大于0的id和用户的映射。</span></span><br><span class="line">        ArrayList&lt;User&gt; lotteryArea = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),</span><br><span class="line">                candidateArea = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        Comparator&lt;User&gt; cntUpTimeDown = (a,b)-&gt; a.cnt!=b.cnt?a.cnt-b.cnt:b.time-a.time,</span><br><span class="line">                cntDownTimeDown = (a,b)-&gt;a.cnt!=b.cnt?b.cnt-a.cnt:b.time-a.time;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ids.length);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;ids.length; ++i)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> map.get(ids[i]);</span><br><span class="line">            <span class="keyword">if</span>(!(user == <span class="literal">null</span> &amp;&amp; ops[i] == <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="comment">// user == null 表示用户还没买过货物，或者用户买的货物都退了。此时如果还发生退货事件，那么不用理会了</span></span><br><span class="line">                <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">                    user = <span class="keyword">new</span> <span class="title class_">User</span>(ids[i],i);</span><br><span class="line">                    map.put(ids[i],user);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ops[i] == <span class="number">0</span>)--user.cnt;</span><br><span class="line">                <span class="keyword">else</span> ++user.cnt;</span><br><span class="line">                <span class="keyword">if</span>(user.cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                    map.remove(ids[i]);</span><br><span class="line">                    lotteryArea.remove(user);</span><br><span class="line">                    candidateArea.remove(user);</span><br><span class="line">                    <span class="keyword">if</span>(lotteryArea.size() &lt; k &amp;&amp; !candidateArea.isEmpty())&#123;</span><br><span class="line">                        <span class="comment">// 如果移除的是获奖区域的用户，且候选区域还有人的情况下，需要从候选区域选择一个最好的，放入获奖区域</span></span><br><span class="line">                        candidateArea.sort(cntUpTimeDown);</span><br><span class="line">                        <span class="type">User</span> <span class="variable">candidate</span> <span class="operator">=</span> candidateArea.remove(candidateArea.size() - <span class="number">1</span>);</span><br><span class="line">                        candidate.time = i;</span><br><span class="line">                        lotteryArea.add(candidate);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(lotteryArea.size() &lt; k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!lotteryArea.contains(user)) lotteryArea.add(user);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!candidateArea.contains(user) &amp;&amp; !lotteryArea.contains(user))&#123;</span><br><span class="line">                            <span class="comment">// 获奖区域已经满了。如果他既不在获奖区域也不在候选区域，那么加入候选区域</span></span><br><span class="line">                            candidateArea.add(user);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 排序后，把候选区域购买数量最大的 且来的最早的 和 获奖区域购买数量最小的 且来的最早的，互换</span></span><br><span class="line">                        <span class="keyword">if</span>(!candidateArea.isEmpty())&#123;</span><br><span class="line">                            candidateArea.sort(cntUpTimeDown);</span><br><span class="line">                            lotteryArea.sort(cntDownTimeDown);</span><br><span class="line">                            <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> candidateArea.get(candidateArea.size() - <span class="number">1</span>);</span><br><span class="line">                            <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> lotteryArea.get(lotteryArea.size() - <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">if</span>(user1.cnt &gt; user2.cnt)&#123;</span><br><span class="line">                                user1.time = user2.time = i;</span><br><span class="line">                                candidateArea.set(candidateArea.size() - <span class="number">1</span>,user2);</span><br><span class="line">                                lotteryArea.set(lotteryArea.size()-<span class="number">1</span>,user1);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList&lt;Integer&gt; ansItem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(lotteryArea.size());</span><br><span class="line">            <span class="keyword">for</span> (User lotteryUser : lotteryArea) &#123;</span><br><span class="line">                ansItem.add(lotteryUser.id);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(ansItem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ids = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                ops=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        1,2</span></span><br><span class="line"><span class="comment">        1,2</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        3,4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lotteryUidList = getLotteryUidList(ids, ops, k);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; integers : lotteryUidList) &#123;</span><br><span class="line">            System.out.println(integers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">        <span class="type">int</span> id,cnt,time;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> t)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            time = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(N^2)$，因为ArrayList删除的时候，时间复杂的是平方级别。</p><h1 id="3-最优解"><a href="#3-最优解" class="headerlink" title="3. 最优解"></a>3. 最优解</h1><h2 id="3-1-算法分析"><a href="#3-1-算法分析" class="headerlink" title="3.1. 算法分析"></a>3.1. 算法分析</h2><p>上面的平凡解中在每一次事件发生的时候，需要在候选区域中寻找购买数量最多，且来的最早的用户。每次使用排序的方式，效率较低。</p><p>我们可以使用堆维护候选区域和获奖区域，候选区域组成 按照购买数量升序，进入时间降序的大顶堆，同时获奖区域 按照购买数量降序，进入时间降序的大顶堆；</p><p>则候选区域堆顶就是购买数量最多且来的最早的，获奖区域堆顶就是购买数量最少，且来的最早的。同时堆可以随着元素的添加删除动态调整。</p><p>可以在堆结构中加一个contains方法，来判断一个元素是否在堆中。</p><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LotteryGameMethod2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getLotteryUidList</span><span class="params">(<span class="type">int</span>[] ids, <span class="type">int</span>[] ops, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        HashMap&lt;Integer,User&gt; map  = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        MyHeap&lt;User&gt; lotteryArea = <span class="keyword">new</span> <span class="title class_">MyHeap</span>&lt;&gt;((a,b)-&gt;a.cnt!= b.cnt?b.cnt-a.cnt:b.time-a.time),</span><br><span class="line">                candidateArea = <span class="keyword">new</span> <span class="title class_">MyHeap</span>&lt;&gt;((a,b)-&gt;a.cnt!=b.cnt?a.cnt-b.cnt:b.time-a.time);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,len=ids.length;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;len;++i)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> map.get(ids[i]);</span><br><span class="line">            <span class="keyword">if</span>(!(user==<span class="literal">null</span> &amp;&amp; ops[i] ==<span class="number">0</span> ))&#123;</span><br><span class="line">                <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">                    user = <span class="keyword">new</span> <span class="title class_">User</span>(ids[i],i);</span><br><span class="line">                    map.put(ids[i],user);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ops[i]==<span class="number">0</span>)--user.cnt;</span><br><span class="line">                <span class="keyword">else</span> ++user.cnt;</span><br><span class="line">                <span class="keyword">if</span>(user.cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                    map.remove(ids[i]);</span><br><span class="line">                    lotteryArea.remove(user);</span><br><span class="line">                    candidateArea.remove(user);</span><br><span class="line">                    <span class="keyword">if</span> (lotteryArea.size()&lt;k &amp;&amp; candidateArea.size() &gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">User</span> <span class="variable">poll</span> <span class="operator">=</span> candidateArea.poll();</span><br><span class="line">                        poll.time = i;</span><br><span class="line">                        lotteryArea.add(poll);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(lotteryArea.size()&lt;k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!lotteryArea.contains(user))lotteryArea.add(user);</span><br><span class="line">                        <span class="keyword">else</span> lotteryArea.update(user);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!lotteryArea.contains(user) &amp;&amp; !candidateArea.contains(user))&#123;</span><br><span class="line">                            candidateArea.add(user);</span><br><span class="line">                        &#125;</span><br><span class="line">                        candidateArea.update(user);</span><br><span class="line">                        lotteryArea.update(user);</span><br><span class="line">                        <span class="keyword">if</span>(candidateArea.size() &gt; <span class="number">0</span> &amp;&amp; candidateArea.peek().cnt &gt; lotteryArea.peek().cnt)&#123;</span><br><span class="line">                            <span class="type">User</span> <span class="variable">candidate</span> <span class="operator">=</span> candidateArea.poll();</span><br><span class="line">                            <span class="type">User</span> <span class="variable">lottery</span> <span class="operator">=</span> lotteryArea.poll();</span><br><span class="line">                            candidate.time = lottery.time = i;</span><br><span class="line">                            candidateArea.add(lottery);</span><br><span class="line">                            lotteryArea.add(candidate);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Integer&gt; ansItem = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(lotteryArea.size());</span><br><span class="line">            <span class="keyword">for</span> (User lotteryUser : lotteryArea.getAll()) &#123;</span><br><span class="line">                ansItem.add(lotteryUser.id);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(ansItem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">        <span class="type">int</span> id, cnt,time;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> t)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.id=id;</span><br><span class="line">            time=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHeap</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> ArrayList&lt;T&gt; arrayList;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> HashMap&lt;T,Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Comparator&lt;T&gt; comparator;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyHeap</span><span class="params">(Comparator&lt;T&gt; comparator)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">            arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T data)</span>&#123;</span><br><span class="line">            indexMap.put(data,size);</span><br><span class="line">            arrayList.add(data);</span><br><span class="line">            heapInsert(size++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T data)</span>&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> indexMap.get(data);</span><br><span class="line">            <span class="keyword">if</span>(index!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(index == size-<span class="number">1</span>)&#123;</span><br><span class="line">                    arrayList.remove(--size);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    swap(arrayList.get(index),arrayList.get(--size));</span><br><span class="line">                    resign(index);</span><br><span class="line">                    arrayList.remove(size);</span><br><span class="line">                &#125;</span><br><span class="line">                indexMap.remove(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">data</span> <span class="operator">=</span> arrayList.get(<span class="number">0</span>);</span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">                arrayList.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(arrayList.get(<span class="number">0</span>),arrayList.get(size));</span><br><span class="line">                resign(<span class="number">0</span>);</span><br><span class="line">                arrayList.remove(size);</span><br><span class="line">            &#125;</span><br><span class="line">            indexMap.remove(data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> arrayList.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(T data)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> indexMap.containsKey(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(T data)</span>&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> indexMap.get(data);</span><br><span class="line">            <span class="keyword">if</span>(index!=<span class="literal">null</span>)resign(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ArrayList&lt;T&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> arrayList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resign</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">            heapInsert(index);</span><br><span class="line">            heapify(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">            <span class="type">int</span> parent;</span><br><span class="line">            <span class="keyword">while</span>(comparator.compare(arrayList.get(index),arrayList.get(parent = (index-<span class="number">1</span>)/<span class="number">2</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                swap(arrayList.get(index),arrayList.get(parent));</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">            <span class="type">int</span> child, bnd = size&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;bnd)&#123;</span><br><span class="line">                child = (index&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(child+<span class="number">1</span>&lt;size &amp;&amp; comparator.compare(arrayList.get(child),arrayList.get(child+<span class="number">1</span>)) &lt; <span class="number">0</span>)++child;</span><br><span class="line">                <span class="keyword">if</span>(comparator.compare(arrayList.get(index),arrayList.get(child)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    swap(arrayList.get(index),arrayList.get(child));</span><br><span class="line">                    index = child;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(T t1, T t2)</span>&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">index1</span> <span class="operator">=</span> indexMap.get(t1),</span><br><span class="line">                    index2 = indexMap.get(t2);</span><br><span class="line">            arrayList.set(index1,t2);</span><br><span class="line">            arrayList.set(index2,t1);</span><br><span class="line">            indexMap.put(t1,index2);</span><br><span class="line">            indexMap.put(t2,index1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ids = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                ops=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1</span></span><br><span class="line"><span class="comment">        1,2</span></span><br><span class="line"><span class="comment">        1,2</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        2,3</span></span><br><span class="line"><span class="comment">        3,4</span></span><br><span class="line"><span class="comment">        3,4</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lotteryUidList = getLotteryUidList(ids, ops, k);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; integers : lotteryUidList) &#123;</span><br><span class="line">            System.out.println(integers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂的$O(N\log_2N)$</p><h1 id="4-测试程序"><a href="#4-测试程序" class="headerlink" title="4. 测试程序"></a>4. 测试程序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LotteryGameMethodTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">100_0000</span>,maxArrayLen = <span class="number">100</span>;</span><br><span class="line">        <span class="type">LotteryGameMethod1</span> <span class="variable">lotteryGameMethod1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LotteryGameMethod1</span>();</span><br><span class="line">        <span class="type">LotteryGameMethod2</span> <span class="variable">lotteryGameMethod2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LotteryGameMethod2</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;times;++i)&#123;</span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> random.nextInt(maxArrayLen)+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] ids = <span class="keyword">new</span> <span class="title class_">int</span>[len], ops = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>;j&lt;len;++j)&#123;</span><br><span class="line">                ids[j] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">                ops[j] = random.nextInt(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> random.nextInt(<span class="number">20</span>)+<span class="number">1</span>;</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; lotteryUidList1 = LotteryGameMethod1.getLotteryUidList(ids, ops, k);</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; lotteryUidList2 = LotteryGameMethod2.getLotteryUidList(ids, ops, k);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;len;++j)&#123;</span><br><span class="line">                List&lt;Integer&gt; integers1 = lotteryUidList1.get(j);</span><br><span class="line">                List&lt;Integer&gt; integers2 = lotteryUidList2.get(j);</span><br><span class="line">                <span class="keyword">if</span>(integers1.size()!=integers2.size())&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Oops&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                integers1.sort(Integer::compare);</span><br><span class="line">                integers2.sort(Integer::compare);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;integers1.size();++m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!integers1.get(m).equals(integers2.get(m)))&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Oops&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 问题 </category>
          
          <category> 堆相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2022/10/10/enhanced-heap/"/>
      <url>/2022/10/10/enhanced-heap/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-数据结构介绍"><a href="#1-数据结构介绍" class="headerlink" title="1. 数据结构介绍"></a>1. 数据结构介绍</h1><p>要求实现一种堆数据结构，具有如下操作：</p><ol><li>可以动态添加元素</li><li>可以修改给定元素</li><li>可以动态删除元素，可以删除指定位置的元素，以及删除给定的元素</li><li>获取堆顶元素</li><li>弹出堆顶</li><li>获取堆中的元素个数</li><li>用户可以指定比较策略</li></ol><h1 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h1><ul><li>对于可以动态增删元素，可以使用动态数组ArrayList来实现；</li><li>如果需要对给定的元素进行操作，我们需要知道这个元素在堆数组中的下标，因此需要一个查找表记录每一个元素及其在堆数组中的下标；</li><li>对于修改元素，我们只需要将修改后的元素同时做一次heapInsert和heapify即可，因为修改后，元素的排序指标可能变大也可能变小，或者不变，因此heapInsert和heapify最多只会发生一个；这个叫做元素的resign（重新分配）</li><li>对于删除元素，我们只需要把最后一个元素last和被删除的元素交换，堆的大小减少1，然后resign这个last元素，如果被删除的刚好是最后一个，直接删除即可。</li><li>可以使用比较器让比较策略灵活指定。</li></ul><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancedHeap</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;T&gt; arrayList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;T,Integer&gt; indexMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Comparator&lt;T&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EnhancedHeap</span><span class="params">(Comparator&lt;T&gt; comparator)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line">        arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        arrayList.add(data);</span><br><span class="line">        indexMap.put(data,size);</span><br><span class="line">        heapInsert(size++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> indexMap.get(data);</span><br><span class="line">        <span class="keyword">if</span>(index != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index == size -<span class="number">1</span>)&#123;</span><br><span class="line">                arrayList.remove(--size);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                swap(arrayList.get(index),arrayList.get(--size));</span><br><span class="line">                arrayList.remove(size);</span><br><span class="line">                resign(index);</span><br><span class="line">            &#125;</span><br><span class="line">            indexMap.remove(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(T data)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> indexMap.get(data);</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="literal">null</span>)resign(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="type">T</span> <span class="variable">ret</span>  <span class="operator">=</span> arrayList.get(<span class="number">0</span>);</span><br><span class="line">         swap(ret,arrayList.get(size - <span class="number">1</span>));</span><br><span class="line">         arrayList.remove(--size);</span><br><span class="line">         heapify(<span class="number">0</span>);</span><br><span class="line">         indexMap.remove(ret);</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resign</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        heapInsert(index);</span><br><span class="line">        heapify(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="type">int</span> parent;</span><br><span class="line">        <span class="keyword">while</span>(comparator.compare(arrayList.get(index),arrayList.get(parent = (index-<span class="number">1</span>) / <span class="number">2</span> )) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            swap(arrayList.get(index), arrayList.get(parent));</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="type">int</span> child, bound = size &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; bound)&#123;</span><br><span class="line">            child = (index &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(child + <span class="number">1</span> &lt; size &amp;&amp; comparator.compare(arrayList.get(child),arrayList.get(child+<span class="number">1</span>)) &lt; <span class="number">0</span>) ++child;</span><br><span class="line">            <span class="keyword">if</span>(comparator.compare(arrayList.get(index),arrayList.get(child)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                swap(arrayList.get(index),arrayList.get(child));</span><br><span class="line">                index = child;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(T t1, T t2)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">index1</span> <span class="operator">=</span> indexMap.get(t1), index2 = indexMap.get(t2);</span><br><span class="line">        arrayList.set(index1,t2);</span><br><span class="line">        arrayList.set(index2,t1);</span><br><span class="line">        indexMap.put(t1,index2);</span><br><span class="line">        indexMap.put(t2,index1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试程序</span></span><br><span class="line">        EnhancedHeap&lt;Info&gt; enhancedHeap = <span class="keyword">new</span> <span class="title class_">EnhancedHeap</span>&lt;&gt;((a,b)-&gt; a.value - b.value);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">1</span>), b = <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">2</span>), c = <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">3</span>);</span><br><span class="line">        enhancedHeap.add(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span>+enhancedHeap.size+<span class="string">&quot;  top: &quot;</span>+enhancedHeap.peek());</span><br><span class="line">        enhancedHeap.add(b);</span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span>+enhancedHeap.size+<span class="string">&quot;  top: &quot;</span>+enhancedHeap.peek());</span><br><span class="line">        enhancedHeap.add(c);</span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span>+enhancedHeap.size+<span class="string">&quot;  top: &quot;</span>+enhancedHeap.peek());</span><br><span class="line">        c.value = <span class="number">7</span>;</span><br><span class="line">        enhancedHeap.update(c);</span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span>+enhancedHeap.size+<span class="string">&quot;  top: &quot;</span>+enhancedHeap.peek());</span><br><span class="line">        enhancedHeap.remove(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span>+enhancedHeap.size+<span class="string">&quot;  top: &quot;</span>+enhancedHeap.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;top: &quot;</span>+enhancedHeap.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span>+enhancedHeap.size+<span class="string">&quot;  top: &quot;</span>+enhancedHeap.peek());</span><br><span class="line">        enhancedHeap.add(<span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span>+enhancedHeap.size+<span class="string">&quot;  top: &quot;</span>+enhancedHeap.peek());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 堆 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="/2022/10/03/heapSort/"/>
      <url>/2022/10/03/heapSort/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-整体思路"><a href="#1-整体思路" class="headerlink" title="1. 整体思路"></a>1. 整体思路</h1><p>和选择排序是一样的，首先在所有元素中选出最大的元素放在最后的位置，然后在剩下的元素中选出最大的放在倒数第二的位置，……，以此类推，直到剩下一个与元素为止。</p><h1 id="2-算法过程"><a href="#2-算法过程" class="headerlink" title="2. 算法过程"></a>2. 算法过程</h1><ol><li><p>首先把待排序的数组原地调整成一个堆结构，什么？不知道堆数据结构，可以看<a href="https://blog.csdn.net/qq_37684467/article/details/117229493">这篇文章</a>；</p></li><li><p>假设数组需要从小到大排序，我们使用大顶堆来完成。数组调整成堆可以使用heapify，线性时间复杂度。</p></li><li><p>只要堆中的元素个数（size）大于1，执行下面的逻辑</p><p>3.1. 把堆顶元素和数组中下标为size-1的元素做交换；</p><p>3.2. size–；</p><p>3.3. 对堆顶元素做heapify操作，调整堆。</p></li></ol><h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3. 代码"></a>3. 代码</h1><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">100_0000</span>, maxArraySize = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">while</span>(times-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> r.nextInt(maxArraySize);</span><br><span class="line">            <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[len], arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) arr1[i] = arr2[i] = r.nextInt(<span class="number">21</span>) - <span class="number">10</span>;</span><br><span class="line">            Arrays.sort(arr1);</span><br><span class="line">            heapSort(arr2);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[i] != arr2[i]) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; ++i) System.out.print(arr1[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; ++i) System.out.print(arr2[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i,len = arr.length;</span><br><span class="line">        <span class="keyword">for</span>(i = (len &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt; -<span class="number">1</span>; --i) heapIfy(arr,len,i); <span class="comment">// 创建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(i = len; i &gt; <span class="number">1</span>;) &#123;<span class="comment">// i就是堆的size</span></span><br><span class="line">            swap(arr,<span class="number">0</span>,--i);</span><br><span class="line">            heapIfy(arr,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapIfy</span><span class="params">(<span class="type">int</span>[] heap, <span class="type">int</span> size, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 堆的元素个数是size，对下标为index的元素做heapify操作</span></span><br><span class="line">        <span class="type">int</span> child, bound = size &gt;&gt; <span class="number">1</span>, v = heap[index];</span><br><span class="line">        <span class="keyword">while</span>(index &lt; bound) &#123;</span><br><span class="line">            child = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(child + <span class="number">1</span> &lt; size &amp;&amp; heap[child + <span class="number">1</span>] &gt; heap[child]) ++child;</span><br><span class="line">            <span class="keyword">if</span>(v &gt;= heap[child]) <span class="keyword">break</span>;</span><br><span class="line">            heap[index] = heap[child];</span><br><span class="line">            index = child;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[index] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
          <category> 堆排序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ls</title>
      <link href="/2022/09/20/ls/"/>
      <url>/2022/09/20/ls/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-命令作用"><a href="#1-命令作用" class="headerlink" title="1. 命令作用"></a>1. 命令作用</h1><p>显示目录中的文件信息。</p><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> [options]... [file]...</span><br></pre></td></tr></table></figure><h1 id="3-命令解释"><a href="#3-命令解释" class="headerlink" title="3. 命令解释"></a>3. 命令解释</h1><ol><li>ls程序可以显示目录中的任何文件信息（包括目录的信息），选项和参数和随意混合使用，后来的选项可以覆盖前面与之不兼容的选项；</li><li>ls命令不带任何选项和参数的情况下，相当于ls . ，显示当前目录的文件信息。对于非选项的命令行参数，例如ls xxx，如果xxx是一个目录的话，那么ls程序就会显示这个目录内的文件信息（非递归，且忽略以.（点号）开头的文件），如果xxx是一个文件的话，那么只是显示它的名称。</li></ol><h1 id="4-选项"><a href="#4-选项" class="headerlink" title="4. 选项"></a>4. 选项</h1><h2 id="4-1-a-–all"><a href="#4-1-a-–all" class="headerlink" title="4.1. -a,–all"></a>4.1. -a,–all</h2><p>不忽略名称以.（点）开头的文件</p><h2 id="4-2-A-–almost-all"><a href="#4-2-A-–almost-all" class="headerlink" title="4.2. -A, –almost-all"></a>4.2. -A, –almost-all</h2><p>不忽略名称以.（点）开头的文件，除了.（当前目录）和..（上一级目录），-a,–all可以覆盖此选项。</p><h2 id="4-3-B"><a href="#4-3-B" class="headerlink" title="4.3. -B"></a>4.3. -B</h2><p>忽略名称以’~‘结尾的，这些文件一般是文本编辑器的备份文件。–ignore&#x3D;’*<del>‘ –ignore&#x3D;’.*</del>‘具有相同的效果。</p><h2 id="4-4-d-–directory"><a href="#4-4-d-–directory" class="headerlink" title="4.4. -d,–directory"></a>4.4. -d,–directory</h2><p>当ls file的时候，如果file是一个目录，那么会显示它立里面的内容，如果想显示目录本身的内容的话，需要使用</p><p>-d选项。</p><h2 id="4-5-–group-directories-first"><a href="#4-5-–group-directories-first" class="headerlink" title="4.5. –group-directories-first"></a>4.5. –group-directories-first</h2><p>会把目录全部显示在文件的前面，文件和目录单独排序。</p><h2 id="4-6-–hide-x3D-PATTERN"><a href="#4-6-–hide-x3D-PATTERN" class="headerlink" title="4.6. –hide&#x3D;PATTERN"></a>4.6. –hide&#x3D;PATTERN</h2><p>隐藏文件名称匹配pattern的文件，如该–all,-a 或者 –almost-all,-A 这些选项在的时候，–hide&#x3D;PATTERN就不起作用了。–ignore&#x3D;PATTERN可以起到相同的作用，但是–all,-a 或者 –almost-all,-A 这些选项对–ignore&#x3D;PATTERN不起作用。</p><p>例如当前目录中有一个文件README<del>，使用ls –hide&#x3D;’*</del>‘ -A，不能隐藏掉README<del>，但是ls –ignore&#x3D;’*</del>‘ -A 就可以。</p><h2 id="4-7-I-pattern-–ignore-x3D-pattern"><a href="#4-7-I-pattern-–ignore-x3D-pattern" class="headerlink" title="4.7. -I pattern, –ignore&#x3D;pattern"></a>4.7. -I pattern, –ignore&#x3D;pattern</h2><p>忽略文件名称和shell 模式匹配的文件。这里的pattern不是正则，是shell的glob表达式。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> --ignore=<span class="string">&#x27;.??*&#x27;</span> --ignore=<span class="string">&#x27;.[^.]&#x27;</span> --ignore=<span class="string">&#x27;#*&#x27;</span></span><br></pre></td></tr></table></figure><p>第一个选项表示忽略文件名称以.开头的，且文件名称长度至少是三个字符的文件；</p><p>第二个选项表示忽略文件名称以.开头的，且名称不是..的文件；</p><p>第三个选项表示忽略文件名称是以’#’开头的文件；</p><h2 id="4-8-R-–recursive"><a href="#4-8-R-–recursive" class="headerlink" title="4.8. -R, –recursive"></a>4.8. -R, –recursive</h2><p>递归显示目录的内容。</p><h2 id="4-9-i-–inode"><a href="#4-9-i-–inode" class="headerlink" title="4.9 -i, –inode"></a>4.9 -i, –inode</h2><p>在文件名称的左边显示inode信息，inode在一个文件系统中是唯一的。</p><h2 id="4-10-h-–human-readable"><a href="#4-10-h-–human-readable" class="headerlink" title="4.10  -h, –human-readable"></a>4.10  -h, –human-readable</h2><p>以人类可读的方式显示文件的size，文件大小是以字节数显示的，这个选项可以在适当的时候，显示KB，MB等，这里的M默认是2的10次方（1048576）。这个选项与--block-size&#x3D;human-reabable是等价的。</p><p>如果需要让单位以10为基数，即M是10的三次方，可以使用 --si选项。</p><h2 id="4-11-l-–format-x3D-long-–format-x3D-verbose"><a href="#4-11-l-–format-x3D-long-–format-x3D-verbose" class="headerlink" title="4.11. -l, –format&#x3D;long, –format&#x3D;verbose"></a>4.11. -l, –format&#x3D;long, –format&#x3D;verbose</h2><p>长格式显示。除了每一个文件的文件名称，还会显示文件的类型，文件模式位，硬链接的数目，属主，属组，文件size，时间戳（修改时间）。</p><p>在显示每一个目录信息的开头，显示total blocks信息，代表文件系统为这个目录下的所有文件分配的磁盘块的个数<a href="%E5%85%B6%E5%AE%9E%E5%AE%83%E7%BB%9F%E8%AE%A1%E7%9A%84%E6%98%AF%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E7%A3%81%E7%9B%98%E5%9D%97%E6%80%BB%E6%95%B0%EF%BC%8C%E5%8D%B3%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%8D%A0%E7%94%A84%E4%B8%AA%E7%A3%81%E7%9B%98%E5%9D%97%EF%BC%8C%E4%B8%94%E5%AE%83%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%A1%AC%E9%93%BE%E6%8E%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E7%9A%84%E7%A3%81%E7%9B%98%E5%9D%97%E4%BC%9A%E8%AE%A1%E7%AE%97%E4%B8%A4%E6%AC%A1%EF%BC%8C%E8%BF%99%E6%9C%89%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%AAbug">^1</a>。磁盘块默认1024字节。</p><p>文件类型都有：</p><table><thead><tr><th>文件类型代号</th><th>文件类型</th></tr></thead><tbody><tr><td>-</td><td>普通文件</td></tr><tr><td>b</td><td>块设备文件，例如硬盘</td></tr><tr><td>c</td><td>字符设备文件，例如键盘</td></tr><tr><td>C</td><td>high performance (“contiguous data”) file</td></tr><tr><td>d</td><td>目录</td></tr><tr><td>D</td><td>door (Solaris)</td></tr><tr><td>l</td><td>符号链接，软链接</td></tr><tr><td>M</td><td>off-line (“migrated”) file (Cray DMF)</td></tr><tr><td>n</td><td>network special file (HP-UX)</td></tr><tr><td>p</td><td>FIFO，命名管道</td></tr><tr><td>P</td><td>port (Solaris)</td></tr><tr><td>s</td><td>套接字文件</td></tr><tr><td>?</td><td>其他文件类型</td></tr><tr><td>D</td><td>door (Solaris)</td></tr><tr><td>l</td><td>符号链接，软链接</td></tr><tr><td>M</td><td>off-line (“migrated”) file (Cray DMF)</td></tr><tr><td>n</td><td>network special file (HP-UX)</td></tr></tbody></table><h2 id="4-12-n-–numeric-uid-gid"><a href="#4-12-n-–numeric-uid-gid" class="headerlink" title="4.12. -n, –numeric-uid-gid"></a>4.12. -n, –numeric-uid-gid</h2><p>以长格式显示文件信息，但文件的所有者和所在组使用右对齐的数字ID显示，而不是使用左对齐的名称显示。</p><h2 id="4-13-–author"><a href="#4-13-–author" class="headerlink" title="4.13. –author"></a>4.13. –author</h2><p>用于长格式显示的情况下，需要与-l配合使用。显示文件的作者。在GNU&#x2F;Hurd系统中，文件的作者和拥有者可以是不一样的，对其他系统来说，他们俩是一个意思。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> shell </category>
          
          <category> 常用命令 </category>
          
          <category> 目录操作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwd</title>
      <link href="/2022/09/19/pwd/"/>
      <url>/2022/09/19/pwd/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-命令作用"><a href="#1-命令作用" class="headerlink" title="1. 命令作用"></a>1. 命令作用</h1><p>显示shell的当前工作目录中的绝对路径。</p><h1 id="2-选项"><a href="#2-选项" class="headerlink" title="2. 选项"></a>2. 选项</h1><h2 id="2-1-L"><a href="#2-1-L" class="headerlink" title="2.1. -L"></a>2.1. -L</h2><p>默认选项，打印出的路径包含符号链接。</p><h2 id="2-2-P"><a href="#2-2-P" class="headerlink" title="2.2. -P"></a>2.2. -P</h2><p>打印出的路径不包含符号链接。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> shell </category>
          
          <category> 常用命令 </category>
          
          <category> shell内建命令 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cd</title>
      <link href="/2022/09/19/ShellExecEnv-cd/"/>
      <url>/2022/09/19/ShellExecEnv-cd/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-命令作用"><a href="#1-命令作用" class="headerlink" title="1. 命令作用"></a>1. 命令作用</h1><p>切换当前shell的工作目录。</p><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [-L] [-P [-e]] [<span class="built_in">dir</span>]</span><br></pre></td></tr></table></figure><h1 id="3-命令解释"><a href="#3-命令解释" class="headerlink" title="3. 命令解释"></a>3. 命令解释</h1><h2 id="3-1-特殊参数"><a href="#3-1-特殊参数" class="headerlink" title="3.1. 特殊参数"></a>3.1. 特殊参数</h2><p>cd命令后面一般跟一个目录的路径，可以使用绝对路径或者相对路径。如果不提供目录参数，那么默认$HOME，会被使用，即切换到用户的家目录。如果目录参参数是-，那么-会被替换为$OLDPWD，表示切换到上一次shell的工作目录。</p><p>如果你在dir后面提供了多余的参数，那么会被忽略，比如你执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root foo bar</span><br></pre></td></tr></table></figure><p>foo bar会被忽略。（经过测试，某些版本的shell会打印出错误消息，例如：“bash: cd: too many arguments”）</p><p> 如果一个文件夹的名称叫做“-”，那么使用cd -是不能切换进去的，可以使用cd .&#x2F;- 实现。</p><h2 id="3-2-CDPATH"><a href="#3-2-CDPATH" class="headerlink" title="3.2. CDPATH"></a>3.2. CDPATH</h2><p>如果环境变量CDPATH不为空，当我们直接输入cd dir的时候，如果dir在CDPATH中的某个目录中的时候，cd命令就会直接切换到这个目录。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zk@zk:~$ <span class="built_in">pwd</span></span><br><span class="line">/home/zk</span><br><span class="line">zk@zk:~$ <span class="built_in">ls</span></span><br><span class="line">Desktop    Downloads  Pictures  Public     Tools        Videos</span><br><span class="line">Documents  Music      Projects  Templates  usrlocalbin</span><br><span class="line">zk@zk:~$ CDPATH=/home/zk</span><br><span class="line">zk@zk:~$ <span class="built_in">cd</span> /</span><br><span class="line">zk@zk:/$ <span class="built_in">cd</span> Tools/</span><br><span class="line">/home/zk/Tools</span><br><span class="line">zk@zk:~/Tools$ </span><br></pre></td></tr></table></figure><p>&#x2F;home&#x2F;zk目录下有Tools，Projects等目录，当把CDPATH设置成&#x2F;home&#x2F;zk的时候，此时直接输入cd Tools的时候，cd发现Tools在&#x2F;home&#x2F;zk中，那么就会之际切换到&#x2F;home&#x2F;zk&#x2F;Tools中。</p><p>CDPATH中可以设置不止一个路径，多个路径使用：（冒号）分隔。</p><p>如该cd dir中dir是一个绝对路径，那么CDPATH将被禁用。如该CDPATH中的目录或者-参数指定的目录被成功切换，那么这个目录的绝对路径会被打印到标准输出。</p><h2 id="3-3-的使用"><a href="#3-3-的使用" class="headerlink" title="3.3 $_的使用"></a>3.3 $_的使用</h2><p>$_指的是上一个命令的最后一个参数，利用这个我们可以使用一条命令，新建一个目录的同时，并cd进入这个目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> aa &amp;&amp; <span class="built_in">cd</span> <span class="variable">$_</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> aa ; <span class="built_in">cd</span> <span class="variable">$_</span></span><br></pre></td></tr></table></figure><h1 id="4-选项"><a href="#4-选项" class="headerlink" title="4. 选项"></a>4. 选项</h1><h2 id="4-1-L选项"><a href="#4-1-L选项" class="headerlink" title="4.1. -L选项"></a>4.1. -L选项</h2><p>这是个默认的选项，使用这个选项的时候，当cd dir的时候，如果dir是符号链接的话，cd会切换到符号链接，而不是符号链接指向的目录。例如，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">zk@zk:~$ <span class="built_in">ls</span> -lh</span><br><span class="line">total 40K</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 17 15:02 Desktop</span><br><span class="line">drwxr-xr-x 3 zk zk 4.0K Sep 16 13:29 Documents</span><br><span class="line">drwxr-xr-x 4 zk zk 4.0K Sep 18 22:26 Downloads</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 14 16:45 Music</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 15 12:37 Pictures</span><br><span class="line">drwxrwxr-x 6 zk zk 4.0K Sep 18 22:27 Projects</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 14 16:45 Public</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 14 16:45 Templates</span><br><span class="line">drwxrwxr-x 3 zk zk 4.0K Sep 19 15:44 Tools</span><br><span class="line">lrwxrwxrwx 1 zk zk   15 Sep 19 00:26 usrlocalbin -&gt; /usr/local/bin/</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 14 16:45 Videos</span><br><span class="line">zk@zk:~$ <span class="built_in">cd</span> usrlocalbin</span><br><span class="line">/home/zk/usrlocalbin</span><br><span class="line">zk@zk:~/usrlocalbin$ <span class="built_in">pwd</span></span><br><span class="line">/home/zk/usrlocalbin</span><br><span class="line">zk@zk:~/usrlocalbin$ </span><br></pre></td></tr></table></figure><p>在&#x2F;home&#x2F;zk目录下，有一个usrlocalbin目录，它是一个指向&#x2F;usr&#x2F;local&#x2F;bin的符号链接，cd到这个目录以后，发现当前工作目录在&#x2F;home&#x2F;zk&#x2F;usrlocalbin，而不是在&#x2F;usr&#x2F;local&#x2F;bin。</p><p>如果cd dir中的dir包含..（父目录）和符号链接，那么-L选项会使得先处理..，再处理符号链接。例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/zk/usrlocalbin/../Tools</span><br></pre></td></tr></table></figure><p>这个命令会使得切换到&#x2F;home&#x2F;zk&#x2F;Tools，可见在符号链接usrlocalbin展开之前，已经处理了..</p><h2 id="4-2-P选项"><a href="#4-2-P选项" class="headerlink" title="4.2. -P选项"></a>4.2. -P选项</h2><p>这个选项和-L选项刚好相反，他会在切换到符号链接的时候，真正进入符号链接所指向的目录，并且如果..和符号链接同时出现在目录路径中的时候，会先展开符号链接，再处理..,例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">zk@zk:~$ <span class="built_in">pwd</span> ; <span class="built_in">ls</span> -lh</span><br><span class="line">/home/zk</span><br><span class="line">total 40K</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 17 15:02 Desktop</span><br><span class="line">drwxr-xr-x 3 zk zk 4.0K Sep 16 13:29 Documents</span><br><span class="line">drwxr-xr-x 4 zk zk 4.0K Sep 18 22:26 Downloads</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 14 16:45 Music</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 15 12:37 Pictures</span><br><span class="line">drwxrwxr-x 6 zk zk 4.0K Sep 18 22:27 Projects</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 14 16:45 Public</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 14 16:45 Templates</span><br><span class="line">drwxrwxr-x 3 zk zk 4.0K Sep 19 15:44 Tools</span><br><span class="line">lrwxrwxrwx 1 zk zk   15 Sep 19 00:26 usrlocalbin -&gt; /usr/local/bin/</span><br><span class="line">drwxr-xr-x 2 zk zk 4.0K Sep 14 16:45 Videos</span><br><span class="line">zk@zk:~$ <span class="built_in">cd</span> -P usrlocalbin</span><br><span class="line">zk@zk:/usr/local/bin$ <span class="built_in">cd</span> </span><br><span class="line">zk@zk:~$ <span class="built_in">cd</span> /home/zk/usrlocalbin/../T</span><br><span class="line">Templates/ Tools/     </span><br><span class="line">zk@zk:~$ <span class="built_in">cd</span> -P /home/zk/usrlocalbin/../Tools/</span><br><span class="line">bash: <span class="built_in">cd</span>: /home/zk/usrlocalbin/../Tools/: No such file or directory</span><br><span class="line">zk@zk:~$ </span><br></pre></td></tr></table></figure><p>可见cd到usrlocalbin的时候，shell的工作目录进入了usrlocalbin指向真实目录&#x2F;usr&#x2F;local&#x2F;bin，当我们使用cd -P &#x2F;home&#x2F;zk&#x2F;usrlocalbin&#x2F;..&#x2F;Tools&#x2F;的时候，由于使用了-P选项，usrlocalbin会在解析..之前被展开，由于&#x2F;usr&#x2F;local&#x2F;bin目录的上一级目录中没有Tools目录，因此就会报错。</p><h1 id="4-3-e选项"><a href="#4-3-e选项" class="headerlink" title="4.3. -e选项"></a>4.3. -e选项</h1><p>这个选项和-P选项一起使用，暂时不清楚作用是啥。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> shell </category>
          
          <category> 常用命令 </category>
          
          <category> shell内建命令 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>od</title>
      <link href="/2022/09/07/LinuxTextShowCommand-od/"/>
      <url>/2022/09/07/LinuxTextShowCommand-od/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-命令作用"><a href="#1-命令作用" class="headerlink" title="1. 命令作用"></a>1. 命令作用</h1><p>od命令可以把文件的内容以字节块的形式展示，可以让我们看到文件的二进制数据。</p><h1 id="2-展示格式"><a href="#2-展示格式" class="headerlink" title="2. 展示格式"></a>2. 展示格式</h1><p>od命令是一行一行展示文件内容的，每一行的展示格式如下：</p><p>偏移量  字节块1 字节块2 字节块3……</p><p>偏移量是使用8进制表示的整数，代表当前展示的是文件中第几个字节开始的，默认偏移量是从0开始</p><p>每一个字节块的长度默认是C语言short int类型的字节长度，一般是两个字节，用8进制数表示，默认一行展示16个字节。</p><h1 id="3-选项"><a href="#3-选项" class="headerlink" title="3. 选项"></a>3. 选项</h1><h2 id="3-1-w-n-或-width-n"><a href="#3-1-w-n-或-width-n" class="headerlink" title="3.1. -w[n] 或 --width[-n]"></a>3.1. -w[n] 或 --width[-n]</h2><p>设置od命令一行展示的字节个数，默认是16，如果指定了选项，但是没有给出n，那么是32字节</p><h2 id="3-2-endian-x3D-order"><a href="#3-2-endian-x3D-order" class="headerlink" title="3.2. --endian&#x3D;order"></a>3.2. --endian&#x3D;order</h2><p>当od命令一个字节块包含多个字节的时候，字节展示的顺序，order有大端方式（big）和小断方式（little）。</p><h2 id="3-3-A-radix-或-address-radix-x3D-radix"><a href="#3-3-A-radix-或-address-radix-x3D-radix" class="headerlink" title="3.3. -A radix 或 --address-radix&#x3D;radix"></a>3.3. -A radix 或 --address-radix&#x3D;radix</h2><p>设置偏移量的显示格式，radix有如下选择：</p><ul><li>d：十进制</li><li>o：8进制（默认）</li><li>x：十六进制</li><li>n：不显示偏移量</li></ul><h2 id="3-4-t-type-或-format-x3D-type"><a href="#3-4-t-type-或-format-x3D-type" class="headerlink" title="3.4. -t type 或 --format&#x3D;type"></a>3.4. -t type 或 --format&#x3D;type</h2><p>指定字节块的展示样式，od是按照字节块展示数据的，那么一个字节块是展示成字符，十进制数字，还是浮点数呢？需要我们指定。</p><p>type的取值：</p><ul><li>a：以字符形式展示数据，一个字节一组，且只看低7位组成的ASCII的值，如果是可打印的字符，那么对应的字符，有些字符会换成字符的名称展示，例如如果是空格，打印sp，如果是换行打印nl，是0字节则打印nul；</li><li>c：一个字节一组，如果是可打印的字符，那么打印其ASCII的值，否则如果可以表示成使用反斜杠转义的C语言风格的字符，则转义后打印（例如换行就打印为\n），否则使用3位8进制数字表示这个字节。</li><li>d：有符号十进制整数，4个字节一组。</li><li>u：无符号十进制整数，4字节一组。</li><li>f：浮点数，8个字节一组</li><li>o：8进制整数，4字节一组</li><li>x：十六进制，4个字节一组。</li></ul><p>除了a和c以外，剩下的type取值的中字节块包含的字节数可以使用一个是进制数来指定，例如我想让文件内容显示为十进制，但是想一个字节一组，即一个字节显示为一个十进制整数，可以使用-t d1，其中1个字节，刚好数C语言中的char类型的字节长度，也可以写成-t dc</p><p>其他情况类似，字节个数和对应的替换字符如下：</p><ul><li>c：char 1字节</li><li>s：short 2字节</li><li>I： int 4字节</li><li>L： long  8&#x2F;4字节</li><li>F：float 4字节</li><li>D： double 8字节</li><li>L：long double 10&#x2F;12字节</li></ul><p>还有一些快捷选项：</p><ul><li>-a，等于 -t a</li><li>-b，等于 -t o1</li><li>-c，等于 -t c</li><li>-d，等于 -t u2</li><li>-f，等于 -t fF</li><li>-i，等于 -t dI</li><li>-l，等于 -t dL</li><li>-o，等于-t o2</li><li>-s，等于 -t d2</li><li>-x，等于 -t x2</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> shell </category>
          
          <category> 常用命令 </category>
          
          <category> 文件展示命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nl</title>
      <link href="/2022/09/05/LinuxTextShowCommand-nl/"/>
      <url>/2022/09/05/LinuxTextShowCommand-nl/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-命令作用"><a href="#1-命令作用" class="headerlink" title="1. 命令作用"></a>1. 命令作用</h1><p>nl命令允许可以把文本内容打印出来，同时可以给内容加上行号，相比cat命令，你可以控制行号的很多细节（比如对齐方式，显示字符宽度等），同时nl命令可以让你通过几个标号定义逻辑页，可以作为文本的格式化输出工具。</p><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nl</span> [options]... [file]...</span><br></pre></td></tr></table></figure><p>当没有给出文件名称，或者使用-作为文件名称的时候，则nl显示标准输入的内容。</p><h1 id="3-原理解释"><a href="#3-原理解释" class="headerlink" title="3. 原理解释"></a>3. 原理解释</h1><p>nl命令把所有的文件内容看作一整个文档显示，根据分隔标记，把整个文档标记成页的不同部分，即header，body，footer。</p><p>header的分隔符是“:::”，body分割符“::”，footer的分割符是“:”，如果组成footer分割符的两个字符分别是ab的话，那么header的分割符就是ababab，body的就是abab。</p><p>分割符独占一行，即紧跟着每一种分割符的内容被认为是对应的页的部分，直到遇到其他分割符。例如一个文本的内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">\:\:\:</span><br><span class="line">bbb</span><br><span class="line">\:\:</span><br><span class="line">ccc</span><br><span class="line">123</span><br><span class="line">\:</span><br><span class="line">ddd</span><br></pre></td></tr></table></figure><ul><li>bbb属于header</li><li>ccc 123属于body</li><li>ddd属于footer</li></ul><p>第一个分隔符之前的内容也属于body，即aaa是body部分。当然header，body，footer可以在不同文件中。nl在显示文本的时候，会把分隔符替换为空行，默认只会对body添加行号。</p><h1 id="4-选项"><a href="#4-选项" class="headerlink" title="4. 选项"></a>4. 选项</h1><h2 id="4-1-b或-body-numbering-style"><a href="#4-1-b或-body-numbering-style" class="headerlink" title="4.1. -b或 --body-numbering-style"></a>4.1. -b或 --body-numbering-style</h2><p>指定body部分的行号添加策略，style有如下几个选择：</p><ul><li>a：为所有行添加行号</li><li>b：只为非空行添加行号，body默认是这个</li><li>n：不添加行号</li></ul><p>类似的，也可以指定header和footer的行号策略，选项分别如下：</p><ul><li>-f style 或 --footer-numbering&#x3D;style 指定footer的行号策略；</li><li>-h style 或 --header-numbering&#x3D;style 指定header的行号策略</li></ul><h2 id="4-2-d-cd或-section-delimiter-x3D-cd"><a href="#4-2-d-cd或-section-delimiter-x3D-cd" class="headerlink" title="4.2. -d cd或 --section-delimiter&#x3D;cd"></a>4.2. -d cd或 --section-delimiter&#x3D;cd</h2><p>这个选项指定分隔符，注意cd是两个字符，这样的话，cdcdcd后面的部分是header，cdcd后面的部分是body，cd后面的部分是footer了。默认情况下c&#x3D;‘\’，d&#x3D;‘:’，一般来说分隔符只能指定两个字符，当使用GNU扩展的时候，可以指定多个字符，也可以指定为空字符串（此时将禁用页分区的功能了）。</p><h2 id="4-3-i-number或-line-increment-x3D-number"><a href="#4-3-i-number或-line-increment-x3D-number" class="headerlink" title="4.3. -i number或--line-increment&#x3D;number"></a>4.3. -i number或--line-increment&#x3D;number</h2><p>这个选项指定行号的增量，例如初始行号是1，那么下一行是2，此时增量为1（默认是1），也可以指定负数。</p><h2 id="4-4-l-number或-join-blank-lines-x3D-number"><a href="#4-4-l-number或-join-blank-lines-x3D-number" class="headerlink" title="4.4. -l number或--join-blank-lines&#x3D;number"></a>4.4. -l number或--join-blank-lines&#x3D;number</h2><p>当有至少number个连续的空行的时候，只为最后一个空行设置行号，当连续空行个数小于number的时候，不为这些空行设置行号。空行指的是这一行，除了换行符以外，没有其他字符。</p><h2 id="4-5-n-format-或-number-format-x3D-format"><a href="#4-5-n-format-或-number-format-x3D-format" class="headerlink" title="4.5. -n format 或 --number-format&#x3D;format"></a>4.5. -n format 或 --number-format&#x3D;format</h2><p>指定行编号的样式，format有如下几个可选的值：</p><ul><li>ln：左对齐，没有前导0</li><li>rn：右对齐，没有前导0（默认）</li><li>rz：右对齐，右前导0</li></ul><p>nl输出的每一行的格式可以描述为这样：</p><p>行号区域 行号和内容的分隔区域 内容其区域</p><p>其中行号区域默认是6字符宽度，当我们的行号从一个比较小的数开始的时候，比如1，那么这个1是如何放置？</p><p>其中左对齐即（x表示空出来的字符）：</p><p>1xxxxx 行号和内容的分隔区域 内容其区域</p><p>右对齐是：</p><p>xxxxx1 行号和内容的分隔区域 内容其区域,</p><p>右对齐，有前导0，即：</p><p>000001 行号和内容的分隔区域 内容其区域,</p><h2 id="4-6-p-或-no-renumber"><a href="#4-6-p-或-no-renumber" class="headerlink" title="4.6. -p 或 --no-renumber"></a>4.6. -p 或 --no-renumber</h2><p>这个选项指定了当一个新的页开始的时候，行号不要从新开始。一般来说，我们可以定义多个header，body和footer，当上一个footer结束，下一个header开始的时候，即为新的一页，新的页开始的时候，行号从新开始的。</p><h2 id="4-7-s-string-或-number-separator-x3D-string"><a href="#4-7-s-string-或-number-separator-x3D-string" class="headerlink" title="4.7. -s string 或 --number-separator&#x3D;string"></a>4.7. -s string 或 --number-separator&#x3D;string</h2><p>上面说了，nl输出的每一行的行号和内容之间有分隔区域，这个选项设置行号和行内容之间的分隔区域，默认是TAB，可以指定任何字符串。</p><h2 id="4-8-v-number-或-starting-line-number-x3D-number"><a href="#4-8-v-number-或-starting-line-number-x3D-number" class="headerlink" title="4.8. -v number 或 --starting-line-number&#x3D;number"></a>4.8. -v number 或 --starting-line-number&#x3D;number</h2><p>设置行号的初始值，默认是1</p><h2 id="4-9-w-number-或-number-width-x3D-number"><a href="#4-9-w-number-或-number-width-x3D-number" class="headerlink" title="4.9. -w number 或 --number-width&#x3D;number"></a>4.9. -w number 或 --number-width&#x3D;number</h2><p>上面说了，nl输出的每一行的行号区域默认是6字符宽度，这个选项用来设置行号区域的字符宽度。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> shell </category>
          
          <category> 常用命令 </category>
          
          <category> 文件展示命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tac</title>
      <link href="/2022/09/03/LinuxTextShowCommand-tac/"/>
      <url>/2022/09/03/LinuxTextShowCommand-tac/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-命令作用"><a href="#1-命令作用" class="headerlink" title="1. 命令作用"></a>1. 命令作用</h1><p>tac命令和cat命令功能差不多，都是读取文件或者标准输入的文本，然后显示在标准输出，只不过tac是按行反序输出的，即先打印最后一行，然后倒数第二行，。。</p><p>例如有一个文件，它的内容如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br></pre></td></tr></table></figure><p>那么使用tac输出的结果就是</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">789</span><br><span class="line">456</span><br><span class="line">123</span><br></pre></td></tr></table></figure><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tac</span> [options]... [file]...</span><br></pre></td></tr></table></figure><p>如果没有文件名称，或者文件名称是-，那么代表标准输入。</p><h1 id="3-命令原理"><a href="#3-命令原理" class="headerlink" title="3. 命令原理"></a>3. 命令原理</h1><p>tac命令的工作原理是根据一个字符串把整个文本切分成分组，然后先打印最后一个分组，再倒数第二个，。。。，最后打印第一个分组，用来拆分的分割字符串默认被附加在每一个分组末尾，tac默认使用换行符作为分割字符串。</p><p>这可能不太好理解，下面我们结合-b选项，讲解一下tac的工作原理。</p><h1 id="4-选项"><a href="#4-选项" class="headerlink" title="4. 选项"></a>4. 选项</h1><h2 id="4-1-b，-before"><a href="#4-1-b，-before" class="headerlink" title="4.1. -b，--before"></a>4.1. -b，--before</h2><p>这个选项可以把分割字符串附加在每一个分组的前面，假设上面的文件每一行都有一个换行符，换行符使用$表示，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123$</span><br><span class="line">456$</span><br><span class="line">789$</span><br></pre></td></tr></table></figure><p>因此整个文本被换行符分割成“123” “456” “789”，由于使用-b选项，因此换行符会被附加在每一个分组前面，因此每一个完整的分组如下：</p><p>“123” “$456”  “$789”，“$”，反着打印结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">789</span><br><span class="line">456123</span><br></pre></td></tr></table></figure><p>即：</p><ol><li>先打印换行符</li><li>打印$789（此时789前面有个换行）</li><li>打印$456</li><li>最后在456后面打印123，456和123之间没有换行</li></ol><h2 id="4-2-s，-separator-x3D-str"><a href="#4-2-s，-separator-x3D-str" class="headerlink" title="4.2. -s，--separator&#x3D;str"></a>4.2. -s，--separator&#x3D;str</h2><p>这个选项可以修改分割字符串，例如我们使用-s “ww”，那么我们使用这个选项打印如下文本 “aaawwbwswwdd$”（$代表换行），即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;aaawwbwswwdd&quot;</span> &gt; test.txt</span><br><span class="line"><span class="built_in">tac</span> -s <span class="string">&quot;ww&quot;</span> test.txt</span><br></pre></td></tr></table></figure><p>熟悉根据分割字符串“ww”，原始文本被分割成“aaaww”，“bwsww”，“dd$”，那么打印出来的结果就是</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dd</span><br><span class="line">bwswwaaaww</span><br></pre></td></tr></table></figure><p>如果此时加上-b选项，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tac</span> -b -s <span class="string">&quot;ww&quot;</span> test.txt</span><br></pre></td></tr></table></figure><p>熟悉根据分割字符串“ww”，原始文本被分割成“aaa”，“wwbws”，“wwdd$”，那么打印出来的结果就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wwdd</span><br><span class="line">wwbwsaaa</span><br></pre></td></tr></table></figure><h2 id="4-3-r，-regex"><a href="#4-3-r，-regex" class="headerlink" title="4.3. -r，--regex"></a>4.3. -r，--regex</h2><p>把分割字符串当成正则表达式来解析</p><h2 id="4-4-help和-version"><a href="#4-4-help和-version" class="headerlink" title="4.4. --help和--version"></a>4.4. --help和--version</h2><p>这两个选项会被大部分GNU coreutils 工具包中的程序支持，分别是打印帮助信息和打印当前工具命令的版本号。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> shell </category>
          
          <category> 常用命令 </category>
          
          <category> 文件展示命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cat</title>
      <link href="/2022/09/02/LinuxTextShowCommand-cat/"/>
      <url>/2022/09/02/LinuxTextShowCommand-cat/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h1 id="1-命令作用"><a href="#1-命令作用" class="headerlink" title="1. 命令作用"></a>1. 命令作用</h1><p>这个命令主要的作用是把文件（或者标准输入）的内容显示在标准输出。</p><h1 id="2-命令格式"><a href="#2-命令格式" class="headerlink" title="2. 命令格式"></a>2. 命令格式</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> [options] [file]...</span><br></pre></td></tr></table></figure><p>当没有给出文件名称，或者使用-作为文件名称的时候，则cat显示标准输入的内容。</p><h1 id="3-选项"><a href="#3-选项" class="headerlink" title="3. 选项"></a>3. 选项</h1><table><thead><tr><th>短选项</th><th>长选项</th><th>含义</th></tr></thead><tbody><tr><td></td><td>--help</td><td>打印帮助信息</td></tr><tr><td></td><td>--version</td><td>打印版本号</td></tr><tr><td>-n</td><td>--number</td><td>给输出的行编号，从1开始</td></tr><tr><td>-b</td><td>--number-nonblank</td><td>给输出的行编号，从1开始，跳过所有的空行，如果这个选项生效，那么-n被忽略</td></tr><tr><td>-s</td><td>--squeeze-blank</td><td>合并相邻的多个空行为一个空行</td></tr><tr><td>-v</td><td>--show-nonprinting</td><td>展示除了LFD（换行）和TAB（水平制表符）以外的所有控制字符，展示方式是使用^标记，例如ASCII码中的NUL字符可以使用CTRL+@表示，那么NUL字符就展示为^@。<br/>-v选项使得cat命令一个字节一个字节的展示文件的数据，cat会默认把一个字节的低7位当作ASCII码来展示，如果是可打印字符就展示对应的字符，如果不是可打印的，就使用^+xxx来展示，例如当这个字节是0的时候，就是展示成^@，如果这个字节的最高位是1，那么就在展示的字符前面加上前导的M-，例如-128，就展示为M-^@</td></tr><tr><td>-E</td><td>--show-ends</td><td>把换行符LFD（Line Feed）展示为$，如果在换行符前面有回车符，即\r\n，则一起展示为^M$</td></tr><tr><td>-T</td><td>--show-tabs</td><td>把TAB符展示为^I（爱）</td></tr><tr><td>-e</td><td></td><td>等于-vE</td></tr><tr><td>-t</td><td></td><td>等于-vT</td></tr><tr><td>-A</td><td></td><td>等于-vET</td></tr></tbody></table><h1 id="4-其他使用介绍"><a href="#4-其他使用介绍" class="headerlink" title="4. 其他使用介绍"></a>4. 其他使用介绍</h1><p>借助重定向的操作，可以创建新文件并写入初始化的内容，即：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; NewFile.txt</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> - &gt; NewFile.txt</span><br></pre></td></tr></table></figure><p>此时cat会从标准输入读取字符，直到输入结束（CTRL+D）。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> shell </category>
          
          <category> 常用命令 </category>
          
          <category> 文件展示命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>friends</title>
      <link href="/friends/index.html"/>
      <url>/friends/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
